<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- THREE.js r140 has better Ready Player Me compatibility but use r128 OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        html {
            width: 100%;
            height: 100%;
        }

        /* Echo status indicator - top right corner */
        .status-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 2px solid rgba(139, 0, 255, 0.6);
            box-shadow: 0 8px 32px rgba(139, 0, 255, 0.3);
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
            transition: all 0.3s ease;
        }

        .status-container.speaking {
            border-color: rgba(0, 255, 157, 0.8);
            box-shadow: 0 8px 32px rgba(0, 255, 157, 0.4);
        }

        .status-container.thinking {
            border-color: rgba(255, 193, 7, 0.8);
            box-shadow: 0 8px 32px rgba(255, 193, 7, 0.4);
        }

        .echo-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8B00FF, #FF00FF);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            transition: all 0.3s ease;
        }

        .echo-icon.thinking {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .echo-icon.speaking {
            animation: wave 0.8s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes wave {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-3px) scale(1.05); }
            75% { transform: translateY(3px) scale(0.95); }
        }

        .status-text {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Sidebar layout for status and captions */
        .sidebar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
            z-index: 99999;
        }

        .status-card {
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(139, 0, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .caption-card {
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 3px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 8px 32px rgba(255, 215, 0, 0.2);
            display: none;
        }

        .caption-card.active {
            display: block;
            animation: slideInRight 0.3s ease-out;
        }

        .caption-text {
            color: #FFD700;
            font-size: 18px;
            font-weight: 700;
            line-height: 1.6;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            word-wrap: break-word;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Interactive Content Box - AI controlled media display */
        #contentBox {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            border: 3px solid rgba(139, 0, 255, 0.7);
            border-radius: 16px;
            padding: 20px;
            max-width: 80vw;
            max-height: 80vh;
            display: none;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(139, 0, 255, 0.4);
            backdrop-filter: blur(10px);
            overflow: auto;
        }

        #contentBox.visible {
            display: block;
            animation: contentBoxFadeIn 0.3s ease-out;
        }

        @keyframes contentBoxFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #contentBoxHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(139, 0, 255, 0.3);
        }

        #contentBoxTitle {
            color: #8B00FF;
            font-size: 16px;
            font-weight: bold;
        }

        #contentBoxClose {
            background: rgba(255, 0, 0, 0.7);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: all 0.2s;
        }

        #contentBoxClose:hover {
            background: rgba(255, 0, 0, 1);
            transform: rotate(90deg);
        }

        #contentBoxContent {
            color: white;
            font-size: 14px;
        }

        #contentBoxContent img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }

        #contentBoxContent video {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }

        #contentBoxContent iframe {
            width: 100%;
            min-height: 500px;
            border: none;
            border-radius: 8px;
        }

        /* Drag handle for moving window */
        .drag-handle {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 0, 255, 0.3);
            padding: 8px 40px;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            cursor: move;
            -webkit-app-region: drag;
            color: #fff;
            font-size: 12px;
            text-align: center;
            border: 2px solid rgba(139, 0, 255, 0.5);
            border-top: none;
            z-index: 1000;
            user-select: none;
        }

        .drag-handle:hover {
            background: rgba(139, 0, 255, 0.5);
        }

        /* Compact mode toggle button */
        .toggle-btn {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(139, 0, 255, 0.5);
            color: #8B00FF;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .toggle-btn:hover {
            background: rgba(139, 0, 255, 0.2);
            border-color: #8B00FF;
        }

        /* Compact mode styles */
        body.compact .status-container {
            padding: 8px 12px;
        }

        body.compact .echo-icon {
            width: 30px;
            height: 30px;
            font-size: 18px;
        }

        body.compact .status-text {
            font-size: 12px;
        }

        body.compact .caption {
            font-size: 14px;
            padding: 10px 16px;
        }

        body.compact .captions-container {
            bottom: 40px;
        }
        
        body.compact .drag-handle {
            padding: 4px 20px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <script>
        // Fallbacks & early error capture to avoid ReferenceError if later scripts fail to load
        window.toggleSettings = window.toggleSettings || function() {
            const panel = document.getElementById('settingsPanel');
            if (!panel) return;
            panel.style.display = (panel.style.display === 'block') ? 'none' : 'block';
            try {
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send(panel.style.display === 'block' ? 'settings-panel-opened' : 'settings-panel-closed');
                }
            } catch (e) { /* ignore */ }
        };

        window.closeSettings = window.closeSettings || function() {
            const panel = document.getElementById('settingsPanel');
            if (!panel) return;
            panel.style.display = 'none';
            try {
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('settings-panel-closed');
                }
            } catch (e) { /* ignore */ }
        };

        window.addEventListener('error', function(ev) {
            console.error('[OVERLAY ERROR CAPTURE] ', ev && ev.message, ev && ev.filename, ev && ev.lineno);
        });
    </script>
    <!-- Drag handle for moving window -->
    <div class="drag-handle">‚¨ç Drag to Move Window ‚¨ç</div>

    <!-- Sidebar for status and captions -->
    <div style="position: fixed; top: 20px; right: 20px; width: 350px; display: flex; flex-direction: column; gap: 15px; pointer-events: none; z-index: 99999;">
        <!-- Status Card -->
        <div style="background: rgba(20, 20, 30, 0.85); backdrop-filter: blur(10px); padding: 20px; border-radius: 15px; border: 2px solid rgba(139, 0, 255, 0.5); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                <div class="echo-icon" id="echoIcon">‚ö°</div>
                <div>
                    <div class="status-text" id="statusText">Idle</div>
                    <div id="connectionStatus" style="color: #aaa; font-size: 12px; margin-top: 5px;">üîÑ Connecting...</div>
                </div>
            </div>
        </div>
        
        <!-- Voice Input Card (what you say) -->
        <div id="voiceInputCard" style="background: rgba(20, 30, 50, 0.9); backdrop-filter: blur(10px); padding: 20px; border-radius: 15px; border: 3px solid rgba(0, 191, 255, 0.6); box-shadow: 0 8px 32px rgba(0, 191, 255, 0.2); display: none; max-height: 200px; overflow-y: auto;">
            <div style="color: #00BFFF; font-size: 14px; font-weight: 600; margin-bottom: 8px; opacity: 0.8;">üé§ You said:</div>
            <div id="voiceInputText" style="color: #87CEEB; font-size: 16px; font-weight: 600; line-height: 1.5; text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8); word-wrap: break-word;"></div>
        </div>
        
        <!-- Caption Card (what Echo says) - Closed Caption Style -->
        <div id="captionCard" style="background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); padding: 15px 25px; border-radius: 8px; border: none; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8); display: none; max-height: 200px; overflow-y: auto; position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); max-width: 80%; text-align: center; z-index: 9999;">
            <div id="captionText" style="color: #FFFFFF; font-size: 20px; font-weight: 600; line-height: 1.5; text-shadow: 2px 2px 4px rgba(0, 0, 0, 1); word-wrap: break-word; font-family: Arial, sans-serif;"></div>
        </div>
    </div>

    <button class="toggle-btn" id="toggleBtn" onclick="toggleCompact()" style="pointer-events: auto; z-index: 10000;">Compact Mode</button>
    
    <!-- Settings Button - More visible -->
    <button class="toggle-btn" style="top: 140px; font-size: 24px; padding: 10px 16px; background: rgba(139, 0, 255, 0.3); border-color: #8B00FF; z-index: 10000; pointer-events: auto;" onclick="toggleSettings()" title="Overlay Settings">‚öôÔ∏è</button>
    
    <!-- Settings Panel -->
    <div id="settingsPanel" style="display: none; position: fixed; top: 180px; left: 20px; background: rgba(0, 0, 0, 0.95); border: 2px solid #8B00FF; border-radius: 12px; padding: 20px; min-width: 280px; max-width: 320px; z-index: 10000; max-height: 80vh; overflow-y: auto; pointer-events: auto;">
                <p><strong>üèí Game Mode:</strong></p>
                <select id="gameModeSelector" onchange="changeGameMode()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                    <option value="rocket_league" selected>Rocket League</option>
                    <option value="hockey">NHL Hockey</option>
                </select>
                <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Switch between Rocket League and NHL Hockey mode</p>
                <hr style="border: 1px solid #444; margin: 15px 0;">
                        <hr style="border: 1px solid #444; margin: 15px 0;">
                        <p><strong>üìñ Infinite Story Mode:</strong></p>
                        <div id="infiniteStoryControls" style="display: flex; flex-direction: column; gap: 8px; margin-top: 5px;">
                            <button id="startStoryBtn" onclick="startInfiniteStory()" style="background: #8B00FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">‚ñ∂ Start Infinite Story</button>
                            <button id="stopStoryBtn" onclick="stopInfiniteStory()" style="background: #FF4500; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; display: none;">‚èπ Stop Story</button>
                            <button id="saveStoryBtn" onclick="saveInfiniteStory()" style="background: #00AA00; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; display: none;">üíæ Save Story</button>
                            <button id="loadStoryBtn" onclick="showLoadStoryDialog()" style="background: #666; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">üìÇ Load Story</button>
                            <div id="storyProgress" style="color: #8B00FF; font-size: 13px; margin-top: 5px; display: none;">Story Progress: <span id="storyProgressText">0 events</span></div>
                        </div>
                        <div id="loadStoryDialog" style="display: none; background: #222; border: 1px solid #8B00FF; border-radius: 8px; padding: 12px; margin-top: 10px;">
                            <strong style="color: #8B00FF;">Load Saved Story</strong>
                            <select id="savedStoriesList" style="width: 100%; margin: 8px 0; background: #333; color: white; border-radius: 6px; padding: 6px;"></select>
                            <button onclick="loadSelectedStory()" style="background: #8B00FF; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 600;">Load</button>
                            <button onclick="hideLoadStoryDialog()" style="background: #444; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; margin-left: 8px;">Cancel</button>
                        </div>
                        <p id="infiniteStoryStatus" style="color: #aaa; font-size: 11px; margin-top: 5px;">Start an infinite story. Progress and save or load stories anytime.</p>
                <p><strong>üìπ Display/Capture Source:</strong></p>
                <select id="displaySourceSelector" onchange="changeDisplaySource()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                    <option value="screen" selected>üñ•Ô∏è Screen Capture</option>
                    <option value="obs">üì∫ OBS Virtual Camera</option>
                    <option value="window">ü™ü Window Capture</option>
                </select>
                <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Select video source for game capture</p>
                <hr style="border: 1px solid #444; margin: 15px 0;">
                <p><strong>üß† YOLO Model:</strong></p>
                <select id="yoloModelSelector" onchange="changeYoloModel()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                    <option value="">Loading...</option>
                </select>
                <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Override and load any YOLO model file from weights/</p>
                <hr style="border: 1px solid #444; margin: 15px 0;">
        <h3 style="color: #8B00FF; margin: 0 0 15px 0; font-size: 16px;">‚öôÔ∏è Overlay Settings</h3>
        <div style="color: white; font-size: 13px; line-height: 1.6;">
            <p><strong>üéôÔ∏è AI Commentary:</strong></p>
            <button onclick="toggleCommentary()" id="commentaryBtn" style="background: #00AA00; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-weight: 600;">‚ñ∂ Start Commentary</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Real-time AI commentary on gameplay</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üó£Ô∏è Voice Chat:</strong></p>
            <button onclick="toggleVoiceChat()" id="voiceChatBtn" style="background: #0088FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-weight: 600;">‚ñ∂ Start Voice Chat</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Talk to Echo AI during gameplay</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üí¨ Text Chat:</strong></p>
            <div style="display: flex; gap: 8px; margin-top: 5px; align-items: stretch;">
                <button onclick="toggleChatMode()" id="chatModeBtn" title="Toggle between Text and Image mode" style="background: #666; border: none; color: white; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; min-width: 44px;">üí¨</button>
                <input type="text" id="textChatInput" placeholder="Type your question..." style="flex: 1; background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; font-size: 13px;">
                <button onclick="sendTextMessage()" style="background: #00AA00; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">Send</button>
            </div>
            <p id="chatModeHint" style="color: #aaa; font-size: 11px; margin-top: 5px;">üí¨ Text mode - Ask Echo AI anything</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé≠ AI Personality:</strong></p>
            <select id="personalitySelector" onchange="changePersonality()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose Echo AI's commentary style</p>
            <button onclick="openAvatarGallery()" style="background: linear-gradient(135deg, #8B00FF, #FF00FF); border: none; color: white; padding: 10px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 8px; font-weight: 600; box-shadow: 0 4px 15px rgba(139, 0, 255, 0.4);">üé≠ Choose Personality Avatar</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Browse and select from visual personality gallery</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé§ TTS Engine:</strong></p>
            <select id="ttsEngineSelector" onchange="changeTTSEngine()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose text-to-speech engine</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé§ TTS Voice:</strong></p>
            <select id="voiceSelector" onchange="changeVoice()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose text-to-speech voice</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>ÔøΩ Team Color:</strong></p>
            <div style="display: flex; gap: 8px; margin-top: 5px;">
                <button id="teamBlueBtn" onclick="changeTeamColor('Blue')" 
                        style="flex: 1; background: #0066ff; border: none; color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600;">
                    Blue Team
                </button>
                <button id="teamOrangeBtn" onclick="changeTeamColor('Orange')" 
                        style="flex: 1; background: #ff6600; border: none; color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600;">
                    Orange Team
                </button>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose your team color for tracking</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>ÔøΩüé≠ Load Avatar from URL:</strong></p>
            <div style="display: flex; gap: 8px; margin-top: 5px;">
                <input type="text" id="avatarUrlInput" placeholder="https://models.readyplayer.me/..." style="flex: 1; background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; font-size: 11px;">
                <button onclick="loadAvatarFromUrl()" style="background: #8B00FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">Load</button>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Paste Ready Player Me URL or any GLB model URL</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>ü§ñ AI Provider:</strong></p>
            <select id="aiProviderSelector" onchange="changeAIProvider()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="echo_ai" selected>Echo AI (Ollama)</option>
                <option value="pollinations">Pollinations API</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose AI provider for commentary</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé® Image Mode:</strong></p>
            <button onclick="toggleImageMode()" id="imageModeBtn" style="background: #666; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-weight: 600;">üé® Enable Image Mode</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">AI generates art based on conversation context</p>
            <div id="imagePromptContainer" style="display: none; margin-top: 8px;">
                <input type="text" id="imagePromptInput" placeholder="Describe the art you want..." style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; font-size: 13px; margin-bottom: 8px;">
                <button onclick="generateImageNow()" style="background: #8B00FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; font-weight: 600;">üé® Generate Now</button>
            </div>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üë§ Player Name:</strong></p>
            <input type="text" id="playerNameInput" onchange="changePlayerName()" placeholder="Your name or car (optional)" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; margin-top: 5px; font-size: 13px;">
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Name used in commentary (leave empty for generic)</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üß† Max AI Tokens:</strong></p>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                <input type="range" id="maxTokensSlider" min="100" max="32000" step="100" value="1000" oninput="updateMaxTokensDisplay()" onchange="changeMaxTokens()" style="flex: 1; cursor: pointer;">
                <span id="maxTokensValue" style="color: #8B00FF; font-weight: 600; min-width: 70px;">1000</span>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Maximum tokens for AI responses (higher = longer responses)</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üèí Hockey Teams:</strong></p>
            <div style="margin-top: 5px;">
                <label style="color: #aaa; font-size: 12px;">Home Team:</label>
                <select id="homeTeamInput" onchange="changeHomeTeam()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; margin-top: 3px; font-size: 13px; cursor: pointer;">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div style="margin-top: 8px;">
                <label style="color: #aaa; font-size: 12px;">Away Team:</label>
                <select id="awayTeamInput" onchange="changeAwayTeam()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; margin-top: 3px; font-size: 13px; cursor: pointer;">
                    <option value="">Loading...</option>
                </select>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Team names for NHL hockey mode commentary</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé¨ Highlights:</strong></p>
            <button onclick="openHighlights()" style="background: #FF4500; border: none; color: white; padding: 10px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-weight: 600;">üìÇ Open Highlights Folder</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">View saved gameplay highlights and clips</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üì∫ Twitch Integration:</strong></p>
            <div style="margin-top: 5px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;">
                    <input type="checkbox" id="twitchEnabledCheck" onchange="toggleTwitchEnabled()" style="margin-right: 8px; cursor: pointer;">
                    <span style="color: white; font-size: 13px;">Enable Twitch Chat</span>
                </label>
                <input type="text" id="twitchChannelInput" placeholder="your_channel_name" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; margin-bottom: 8px; font-size: 13px;">
                <input type="password" id="twitchOauthInput" placeholder="oauth:your_token_here" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; width: 100%; margin-bottom: 8px; font-size: 13px;">
                <button onclick="saveTwitchSettings()" style="background: #9147FF; border: none; color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%;">
                    Save Twitch Settings
                </button>
                <p style="color: #aaa; font-size: 10px; margin-top: 8px;">Get token: Run <code style="background: #222; padding: 2px 4px; border-radius: 3px;">python get_twitch_token.py</code></p>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Avatar responds to chat, subs, and follows</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>ü§ñ Ollama Model:</strong></p>
            <select id="ollamaModelSelector" onchange="changeOllamaModel()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose Ollama AI model for commentary</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üå∏ Pollinations Model:</strong></p>
            <select id="pollinationsModelSelector" onchange="changePollinationsModel()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose Pollinations AI model</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé§ Pollinations Voice:</strong></p>
            <select id="pollinationsVoiceSelector" onchange="changePollinationsVoice()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">Loading...</option>
            </select>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose Pollinations TTS voice</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>ÔøΩÔ∏è Visual Effects:</strong></p>
            <div style="margin: 10px 0;">
                <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                    <input type="checkbox" id="showTrackingCheck" onchange="updateVisualization()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                    <span>Show Detection Boxes</span>
                </label>
                <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                    <input type="checkbox" id="enableBallTrailCheck" onchange="updateVisualization()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                    <span>Enable Ball Trail</span>
                </label>
                <div style="margin-top: 10px;">
                    <label style="font-size: 12px; color: #aaa;">Trail Length:</label>
                    <input type="range" id="trailLengthSlider" min="10" max="100" value="30" onchange="updateVisualization()" style="width: 100%; margin-top: 5px;">
                    <span id="trailLengthValue" style="font-size: 11px; color: #aaa;">30</span>
                </div>
                <div style="margin-top: 10px;">
                    <label style="font-size: 12px; color: #aaa;">Trail Style:</label>
                    <select id="trailStyleSelect" onchange="updateVisualization()" style="background: #333; border: 1px solid #666; color: white; padding: 6px; border-radius: 4px; width: 100%; margin-top: 5px; font-size: 12px;">
                        <option value="glow">Glow</option>
                        <option value="solid">Solid</option>
                        <option value="fade">Fade</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="comet">Comet</option>
                        <option value="neon">Neon</option>
                    </select>
                </div>
                <div style="margin-top: 10px;">
                    <label style="font-size: 12px; color: #aaa;">Caption Duration (seconds):</label>
                    <input type="range" id="captionDurationSlider" min="3" max="60" value="10" onchange="updateCaptionDuration()" style="width: 100%; margin-top: 5px;">
                    <span id="captionDurationValue" style="font-size: 11px; color: #aaa;">10s</span>
                </div>
            </div>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Customize overlay visual effects & caption timing</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üé≠ Avatar System:</strong></p>
            <select id="avatarSelector" onchange="loadSelectedAvatar()" style="background: #333; border: 1px solid #666; color: white; padding: 8px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px; font-size: 13px;">
                <option value="">No Avatar (Disabled)</option>
                <option value="male-default">Male Avatar (Default)</option>
                <option value="female-default">Female Avatar (Default)</option>
                <option value="url">üåê Load from URL...</option>
                <option value="custom">üóÇÔ∏è Browse Local File...</option>
            </select>
            <input type="file" id="avatarFilePicker" accept=".glb" style="display: none;" onchange="loadCustomAvatar()">
            <div id="avatarStatus" style="color: #aaa; font-size: 11px; margin-top: 5px;">No avatar loaded</div>
            <button onclick="toggleAvatarWindow()" id="avatarWindowBtn" style="background: #444; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 8px; font-size: 12px;">üì∫ Show Avatar</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">Choose an avatar for lip-sync and animations</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üñ±Ô∏è Click-Through Mode:</strong></p>
            <button onclick="toggleClickThrough()" id="clickThroughBtn" style="background: #8B00FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px;">Enable Click-Through</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">‚ö†Ô∏è You won't be able to click buttons when enabled</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üì∫ Move to Monitor:</strong></p>
            <p style="color: #aaa; margin: 5px 0; font-size: 12px;">
                ‚Ä¢ Drag the purple bar at the top<br>
                ‚Ä¢ Use Windows+Shift+Arrow keys<br>
                ‚Ä¢ Right-click taskbar icon ‚Üí Move
            </p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üß™ Test Caption:</strong></p>
            <button onclick="testCaption('Test caption! Captions are working! üéâ')" style="background: #666; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px;">Show Test Caption + TTS</button>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>üñºÔ∏è Interactive Content Box:</strong></p>
            <button onclick="testContentBox()" style="background: #8B00FF; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px;">Test Content Box</button>
            <p style="color: #aaa; font-size: 11px; margin-top: 5px;">AI can display images, videos, and webpages</p>
            <hr style="border: 1px solid #444; margin: 15px 0;">
            <p><strong>Connection Status:</strong></p>
            <p id="connectionStatus" style="color: #00ff00; margin: 5px 0;">üü¢ Connected</p>
            <button onclick="closeSettings()" style="background: #444; border: none; color: white; padding: 10px 16px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 15px; font-weight: 600;">Close Settings</button>
        </div>
    </div>

    <!-- Interactive Content Box -->
    <div id="contentBox">
        <div id="contentBoxHeader">
            <div id="contentBoxTitle">ü§ñ AI Content</div>
            <button id="contentBoxClose" onclick="hideContentBox()">√ó</button>
        </div>
        <div id="contentBoxContent"></div>
    </div>

    <!-- Movable Chat Input Box -->
    <div id="chatInputBox" style="display: block; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 600px; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); border: 2px solid rgba(139, 0, 255, 0.6); border-radius: 12px; padding: 12px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); z-index: 1000; cursor: move; pointer-events: auto;">
        <div style="display: flex; gap: 10px; align-items: center;">
            <button onclick="toggleMainChatMode()" id="mainChatModeBtn" title="Toggle between Text and Image mode" style="background: #666; border: none; color: white; padding: 10px 12px; border-radius: 8px; cursor: pointer; font-size: 18px; line-height: 1; pointer-events: auto; min-width: 44px;">üí¨</button>
            <input type="text" id="chatInputField" placeholder="Type to chat with Echo AI..." style="flex: 1; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(139, 0, 255, 0.4); color: white; padding: 10px 15px; border-radius: 8px; font-size: 14px; outline: none; pointer-events: auto;" onkeypress="if(event.key==='Enter') sendChatMessage()">
            <button onclick="sendChatMessage()" style="background: linear-gradient(135deg, #8B00FF, #6a00cc); border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s; pointer-events: auto;">Send</button>
            <button onclick="toggleChatBox()" style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(139, 0, 255, 0.4); color: white; padding: 10px; border-radius: 8px; cursor: pointer; font-size: 16px; line-height: 1; pointer-events: auto;">‚úï</button>
        </div>
    </div>

    <div class="captions-container" id="captionsContainer">
        <!-- Captions will be dynamically added here -->
    </div>

    <!-- Canvas for tracking visualization -->
    <canvas id="trackingCanvas" style="position: fixed; top: 0; left: 0; pointer-events: none; z-index: 0;"></canvas>

    <!-- Avatar Display Container - Transparent, no toolbar -->
    <div id="avatarContainer" style="display: none; position: fixed; bottom: 20px; left: 20px; width: 300px; height: 400px; background: rgba(0, 0, 0, 0.1); border: 2px solid rgba(139, 0, 255, 0.3); border-radius: 12px; overflow: hidden; z-index: 50; backdrop-filter: blur(5px); cursor: move;" id="avatarDragHandle">
        <canvas id="avatarCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
    </div>

    <script>

                        // --- Infinite Story Mode Logic ---
                        let infiniteStoryActive = false;
                        let infiniteStoryPolling = null;

                        async function startInfiniteStory() {
                            document.getElementById('startStoryBtn').disabled = true;
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/start_infinite_story', { method: 'POST' }, 2, 200);
                                if (data && data.status === 'started') {
                                    infiniteStoryActive = true;
                                    updateInfiniteStoryUI();
                                    pollInfiniteStoryProgress();
                                } else {
                                    alert('Failed to start story: ' + (data?.message || 'Unknown error'));
                                }
                            } catch (e) {
                                alert('Failed to start story: ' + (e && e.message ? e.message : e));
                            }
                            document.getElementById('startStoryBtn').disabled = false;
                        }

                        async function stopInfiniteStory() {
                            document.getElementById('stopStoryBtn').disabled = true;
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/stop_infinite_story', { method: 'POST' }, 2, 200);
                                if (data && data.status === 'stopped') {
                                    infiniteStoryActive = false;
                                    updateInfiniteStoryUI();
                                } else {
                                    alert('Failed to stop story: ' + (data?.message || 'Unknown error'));
                                }
                            } catch (e) {
                                alert('Failed to stop story: ' + (e && e.message ? e.message : e));
                            }
                            document.getElementById('stopStoryBtn').disabled = false;
                        }

                        async function saveInfiniteStory() {
                            document.getElementById('saveStoryBtn').disabled = true;
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/save_infinite_story', { method: 'POST' }, 2, 200);
                                if (data && data.status === 'saved') {
                                    alert('Story saved as: ' + data.filename);
                                } else {
                                    alert('Failed to save story: ' + (data?.message || 'Unknown error'));
                                }
                            } catch (e) {
                                alert('Failed to save story: ' + (e && e.message ? e.message : e));
                            }
                            document.getElementById('saveStoryBtn').disabled = false;
                        }

                        function showLoadStoryDialog() {
                            document.getElementById('loadStoryDialog').style.display = 'block';
                            loadSavedStoriesList();
                        }

                        function hideLoadStoryDialog() {
                            document.getElementById('loadStoryDialog').style.display = 'none';
                        }

                        async function loadSavedStoriesList() {
                            const select = document.getElementById('savedStoriesList');
                            select.innerHTML = '';
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/list_saved_stories', { method: 'GET' }, 2, 200);
                                if (data && Array.isArray(data.stories) && data.stories.length > 0) {
                                    data.stories.forEach(story => {
                                        const opt = document.createElement('option');
                                        opt.value = story;
                                        opt.textContent = story;
                                        select.appendChild(opt);
                                    });
                                } else {
                                    const opt = document.createElement('option');
                                    opt.value = '';
                                    opt.textContent = 'No saved stories found';
                                    select.appendChild(opt);
                                }
                            } catch (e) {
                                const opt = document.createElement('option');
                                opt.value = '';
                                opt.textContent = 'Error loading stories';
                                select.appendChild(opt);
                            }
                        }

                        async function loadSelectedStory() {
                            const select = document.getElementById('savedStoriesList');
                            const story = select.value;
                            if (!story) return;
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/load_infinite_story', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ filename: story })
                                }, 2, 200);
                                if (data && data.status === 'loaded') {
                                    alert('Story loaded: ' + story);
                                    hideLoadStoryDialog();
                                    infiniteStoryActive = true;
                                    updateInfiniteStoryUI();
                                    pollInfiniteStoryProgress();
                                } else {
                                    alert('Failed to load story: ' + (data?.message || 'Unknown error'));
                                }
                            } catch (e) {
                                alert('Failed to load story: ' + (e && e.message ? e.message : e));
                            }
                        }

                        function updateInfiniteStoryUI(progress = null) {
                            document.getElementById('startStoryBtn').style.display = infiniteStoryActive ? 'none' : 'block';
                            document.getElementById('stopStoryBtn').style.display = infiniteStoryActive ? 'block' : 'none';
                            document.getElementById('saveStoryBtn').style.display = infiniteStoryActive ? 'block' : 'none';
                            document.getElementById('storyProgress').style.display = infiniteStoryActive ? 'block' : 'none';
                            if (progress !== null) {
                                document.getElementById('storyProgressText').textContent = progress;
                            }
                        }

                        async function pollInfiniteStoryProgress() {
                            if (infiniteStoryPolling) clearInterval(infiniteStoryPolling);
                            infiniteStoryPolling = setInterval(async () => {
                                try {
                                    const data = await safeFetch('http://127.0.0.1:7862/api/get_infinite_story', { method: 'GET' }, 1, 200);
                                    if (data && data.active) {
                                        infiniteStoryActive = true;
                                        updateInfiniteStoryUI(data.progress || '0 events');
                                    } else {
                                        infiniteStoryActive = false;
                                        updateInfiniteStoryUI('0 events');
                                        clearInterval(infiniteStoryPolling);
                                    }
                                } catch (e) {
                                    // Ignore polling errors (will retry next interval)
                                }
                            }, 2000);
                        }

                        // On load, check if infinite story is active
                        document.addEventListener('DOMContentLoaded', async function() {
                            try {
                                const data = await safeFetch('http://127.0.0.1:7862/api/get_infinite_story', { method: 'GET' }, 1, 200);
                                infiniteStoryActive = !!(data && data.active);
                                updateInfiniteStoryUI(data ? data.progress || '0 events' : '0 events');
                                if (infiniteStoryActive) pollInfiniteStoryProgress();
                            } catch (e) {
                                // Ignore
                            }
                        });
                async function loadYoloModels() {
                    try {
                        const data = await safeFetch('http://127.0.0.1:7862/api/get_yolo_models', { method: 'GET' }, 3, 300);
                        if (!data || !Array.isArray(data.models)) throw new Error('Invalid YOLO models response');
                        const selector = document.getElementById('yoloModelSelector');
                        selector.innerHTML = '';
                        data.models.forEach(m => {
                            const option = document.createElement('option');
                            option.value = m;
                            option.textContent = m;
                            if (m === data.current) {
                                option.selected = true;
                            }
                            selector.appendChild(option);
                        });
                    } catch (error) {
                        console.error('Failed to load YOLO models:', error);
                        // Fallback: populate with default Rocket League model if server doesn't expose endpoint
                        try {
                            const selector = document.getElementById('yoloModelSelector');
                            selector.innerHTML = '';
                            const fallback = 'yolov11x-rocketleague-best.pt';
                            const option = document.createElement('option');
                            option.value = fallback;
                            option.textContent = fallback;
                            option.selected = true;
                            selector.appendChild(option);
                            console.log('[OVERLAY] Using fallback YOLO model:', fallback);
                        } catch (e) {
                            console.warn('[OVERLAY] Could not set fallback YOLO model:', e);
                        }
                    }
                }

                async function changeYoloModel() {
                    const selector = document.getElementById('yoloModelSelector');
                    const model = selector.value;
                    if (!model || model === 'Loading...') return;
                    try {
                        const encodedModel = encodeURIComponent(model);
                        const response = await fetch(`http://127.0.0.1:7862/api/set_yolo_model/${encodedModel}`);
                        const data = await response.json();
                        if (data.status === 'success') {
                            console.log(`‚úì YOLO model changed to: ${model}`);
                        } else {
                            console.error('Failed to change YOLO model:', data.message);
                        }
                    } catch (error) {
                        console.error('Failed to change YOLO model:', error);
                    }
                }
        
        // Suppress repetitive Three.js deprecation warnings
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args.join(' ');
            // Filter out Three.js RGBFormat deprecation warnings
            if (message.includes('THREE.RGBFormat') || 
                message.includes('THREE.WebGLTextures') ||
                message.includes('sRGB encoded textures')) {
                return; // Suppress these specific warnings
            }
            originalWarn.apply(console, args);
        };
        
        let currentState = 'idle';
        let captionQueue = [];
        const MAX_CAPTIONS = 3;
        let trackingCanvas = document.getElementById('trackingCanvas');
        let trackingCtx = trackingCanvas.getContext('2d');
        
        // Set canvas to full screen
        function resizeCanvas() {
            trackingCanvas.width = window.innerWidth;
            trackingCanvas.height = window.innerHeight;
            console.log(`Canvas resized to: ${trackingCanvas.width}x${trackingCanvas.height}`);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function toggleCompact() {
            document.body.classList.toggle('compact');
            const btn = document.getElementById('toggleBtn');
            btn.textContent = document.body.classList.contains('compact') ? 'Full Size' : 'Compact Mode';
        }
        
        async function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                
                // Make overlay focusable for dropdowns
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('settings-panel-opened');
                }
                
                // Load all settings when opening panel
                await Promise.all([
                    loadPersonalities(),
                    loadTTSEngines(),
                    loadVoices(),
                    loadPlayerName(),
                    loadHockeyTeams(),
                    loadOllamaModels(),
                    loadAIProvider(),
                    loadPollinationsModels(),
                    loadPollinationsVoices(),
                    loadVisualization()
                ]);
                // Initialize max tokens slider to default value
                updateMaxTokensDisplay();
            } else {
                panel.style.display = 'none';
                
                // Make overlay unfocusable again
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('settings-panel-closed');
                }
            }
        }
        
        // Robust fetch with retries/backoff and strict JSON parsing
        async function safeFetch(url, options = {}, retries = 3, backoff = 300) {
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const resp = await fetch(url, options);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const text = await resp.text();
                    const ct = (resp.headers.get('content-type') || '').toLowerCase();

                    // If Content-Type indicates JSON or the text looks like JSON, parse it strictly
                    if (ct.includes('application/json') || text.trim().startsWith('{') || text.trim().startsWith('[')) {
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            console.warn('[safeFetch] Invalid JSON from', url, 'snippet:', text.slice(0, 200));
                            throw new Error('Invalid JSON response');
                        }
                    }

                    // Otherwise return raw text
                    return text;
                } catch (err) {
                    // If aborted by AbortController, bubble up immediately
                    if (err && err.name === 'AbortError') throw err;
                    if (attempt === retries) {
                        console.error('[safeFetch] final attempt failed for', url, err);
                        throw err;
                    }
                    console.warn('[safeFetch] attempt', attempt+1, 'failed for', url, err && err.message ? err.message : err);
                    await new Promise(r => setTimeout(r, backoff * Math.pow(2, attempt)));
                }
            }
        }

        async function loadPersonalities() {
            try {
                const data = await safeFetch('http://127.0.0.1:7862/api/get_personalities', { method: 'GET' }, 3, 300);
                console.log('[OVERLAY] Personalities API response:', data);
                console.log('[OVERLAY] personalities_js length:', data.personalities_js?.length);
                console.log('[OVERLAY] personalities_js[0]:', data.personalities_js?.[0]);
                
                const selector = document.getElementById('personalitySelector');
                selector.innerHTML = '';
                
                // Get current personality from config if available
                let current = window.currentPersonality || null;
                if (data.current) current = data.current;
                
                // Use personalities_js if available (full data with names), otherwise fallback to simple list
                const personalitiesList = data.personalities_js || data.personalities;
                
                if (Array.isArray(personalitiesList) && personalitiesList.length > 0 && typeof personalitiesList[0] === 'object') {
                    // New format: array of objects with id, name, prompt
                    console.log('[OVERLAY] Loading', personalitiesList.length, 'personalities (object format)');
                    personalitiesList.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = p.name;
                        if (current && p.id === current) {
                            option.selected = true;
                        }
                        selector.appendChild(option);
                    });
                } else {
                    // Old format: simple array of strings
                    console.log('[OVERLAY] Loading', personalitiesList.length, 'personalities (string format)');
                    personalitiesList.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p;
                        option.textContent = p;
                        if (current && p === current) {
                            option.selected = true;
                        }
                        selector.appendChild(option);
                    });
                }
                console.log('[OVERLAY] ‚úì Loaded', selector.options.length, 'personality options');
            } catch (error) {
                console.error('Failed to load personalities:', error);
            }
        }
        
        async function changePersonality() {
            const selector = document.getElementById('personalitySelector');
            const personality = selector.value;
            
            if (!personality || personality === 'Loading...') return;
            
            try {
                const encodedPersonality = encodeURIComponent(personality);
                const data = await safeFetch(`http://127.0.0.1:7862/api/set_personality/${encodedPersonality}`, { method: 'GET' }, 2, 200);
                
                if (data.status === 'success') {
                    console.log(`‚úì Personality changed to: ${personality}`);
                } else {
                    console.error('Failed to change personality:', data.message);
                }
            } catch (error) {
                console.error('Failed to change personality:', error);
            }
        }
        
        function openAvatarGallery() {
            console.log('[OVERLAY] Opening avatar gallery...');
            if (typeof require !== 'undefined') {
                const { ipcRenderer } = require('electron');
                ipcRenderer.send('open-avatar-gallery');
            }
        }
        
        async function loadPlayerName() {
            try {
                const data = await safeFetch('http://127.0.0.1:7862/api/get_player_name', { method: 'GET' }, 2, 200);
                
                const input = document.getElementById('playerNameInput');
                input.value = data.player_name || '';
            } catch (error) {
                console.error('Failed to load player name:', error);
            }
        }
        
        async function changePlayerName() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();
            
            try {
                const encoded = encodeURIComponent(name || '');
                const response = await fetch(`http://127.0.0.1:7862/api/set_player_name/${encoded}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Player name set to: ${name || '(none)'}`);
                } else {
                    console.error('Failed to set player name:', data.message);
                }
            } catch (error) {
                console.error('Failed to set player name:', error);
            }
        }
        
        async function loadMaxTokens() {
            try {
                const response = await fetch(`http://localhost:${serverPort}/get_config`);
                const config = await response.json();
                const maxTokens = config.echo_max_tokens || 1000;
                document.getElementById('maxTokensSlider').value = maxTokens;
                updateMaxTokensDisplay();
            } catch (error) {
                console.error('Failed to load max tokens:', error);
            }
        }
        
        function updateMaxTokensDisplay() {
            const slider = document.getElementById('maxTokensSlider');
            const display = document.getElementById('maxTokensValue');
            display.textContent = slider.value;
        }
        
        async function changeMaxTokens() {
            const slider = document.getElementById('maxTokensSlider');
            const maxTokens = parseInt(slider.value);
            // Note: Max tokens setting is currently UI-only
            // Backend support will be added in future update
            console.log('Max tokens slider changed to:', maxTokens);
        }
        
        async function loadHockeyTeams() {
            try {
                // Load NHL teams list
                const teamsResponse = await fetch('http://127.0.0.1:7862/api/get_nhl_teams');
                const teamsData = await teamsResponse.json();
                
                // Load current selections
                const currentResponse = await fetch('http://127.0.0.1:7862/api/get_teams');
                const currentData = await currentResponse.json();
                
                // Populate home team dropdown
                const homeSelect = document.getElementById('homeTeamInput');
                homeSelect.innerHTML = '';
                teamsData.teams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team;
                    option.textContent = team;
                    if (team === currentData.home_team) {
                        option.selected = true;
                    }
                    homeSelect.appendChild(option);
                });
                
                // Populate away team dropdown
                const awaySelect = document.getElementById('awayTeamInput');
                awaySelect.innerHTML = '';
                teamsData.teams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team;
                    option.textContent = team;
                    if (team === currentData.away_team) {
                        option.selected = true;
                    }
                    awaySelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load hockey teams:', error);
            }
        }
        
        async function changeHomeTeam() {
            const homeSelect = document.getElementById('homeTeamInput');
            const awaySelect = document.getElementById('awayTeamInput');
            const homeTeam = homeSelect.value;
            const awayTeam = awaySelect.value;
            
            if (!homeTeam || !awayTeam) return;
            
            try {
                const response = await fetch(`http://127.0.0.1:7862/api/set_teams/${encodeURIComponent(homeTeam)}/${encodeURIComponent(awayTeam)}`);
                const data = await response.json();
                if (data.status === 'success') {
                    console.log('Home team updated:', homeTeam);
                } else {
                    alert('Failed to update home team');
                }
            } catch (error) {
                console.error('Failed to update home team:', error);
                alert('Failed to update home team: ' + error.message);
            }
        }
        
        async function changeAwayTeam() {
            const homeSelect = document.getElementById('homeTeamInput');
            const awaySelect = document.getElementById('awayTeamInput');
            const homeTeam = homeSelect.value;
            const awayTeam = awaySelect.value;
            
            if (!homeTeam || !awayTeam) return;
            
            try {
                const response = await fetch(`http://127.0.0.1:7862/api/set_teams/${encodeURIComponent(homeTeam)}/${encodeURIComponent(awayTeam)}`);
                const data = await response.json();
                if (data.status === 'success') {
                    console.log('Away team updated:', awayTeam);
                } else {
                    alert('Failed to update away team');
                }
            } catch (error) {
                console.error('Failed to update away team:', error);
                alert('Failed to update away team: ' + error.message);
            }
        }
        
        async function openHighlights() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/open_highlights', {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.status === 'success') {
                    console.log('Opening highlights folder');
                } else {
                    alert('Failed to open highlights folder: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Failed to open highlights:', error);
                alert('Failed to open highlights folder: ' + error.message);
            }
        }
        
        async function loadVoices() {
            try {
                const data = await safeFetch('http://127.0.0.1:7862/api/get_voices', { method: 'GET' }, 3, 300);
                
                const selector = document.getElementById('voiceSelector');
                selector.innerHTML = '';
                
                data.voices.forEach(v => {
                    const option = document.createElement('option');
                    option.value = v;
                    option.textContent = v;
                    if (v === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load voices:', error);
            }
        }
        
        async function loadTTSEngines() {
            try {
                const data = await safeFetch('http://127.0.0.1:7862/api/get_tts_engines', { method: 'GET' }, 3, 300);
                
                const selector = document.getElementById('ttsEngineSelector');
                selector.innerHTML = '';
                
                data.engines.forEach(e => {
                    const option = document.createElement('option');
                    option.value = e.value;
                    option.textContent = e.label;
                    if (e.value === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load TTS engines:', error);
            }
        }
        
        async function changeTTSEngine() {
            const selector = document.getElementById('ttsEngineSelector');
            const engine = selector.value;
            
            if (!engine || engine === 'Loading...') return;
            
            try {
                const encodedEngine = encodeURIComponent(engine);
                const response = await fetch(`http://127.0.0.1:7862/api/set_tts_engine/${encodedEngine}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì TTS engine changed to: ${engine}`);
                    // Reload voices for the new engine
                    loadVoices();
                } else {
                    console.error('Failed to change TTS engine:', data.message);
                }
            } catch (error) {
                console.error('Failed to change TTS engine:', error);
            }
        }
        
        async function changeVoice() {
            const selector = document.getElementById('voiceSelector');
            const voice = selector.value;
            
            if (!voice || voice === 'Loading...') return;
            
            try {
                const encodedVoice = encodeURIComponent(voice);
                const response = await fetch(`http://127.0.0.1:7862/api/set_voice/${encodedVoice}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Voice changed to: ${voice}`);
                    // Play voice preview
                    try {
                        await fetch('http://127.0.0.1:7862/api/preview_voice');
                        console.log('‚úì Voice preview played');
                    } catch (previewError) {
                        console.error('Failed to preview voice:', previewError);
                    }
                } else {
                    console.error('Failed to change voice:', data.message);
                }
            } catch (error) {
                console.error('Failed to change voice:', error);
            }
        }
        
        async function loadTeamColor() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_team_color');
                const data = await response.json();
                updateTeamColorButtons(data.team_color);
            } catch (error) {
                console.error('Failed to load team color:', error);
            }
        }
        
        async function changeTeamColor(team) {
            try {
                const response = await fetch(`http://127.0.0.1:7862/api/set_team_color/${team}`);
                const data = await response.json();
                if (data.status === 'success') {
                    updateTeamColorButtons(team);
                    console.log('[TEAM] Team color changed to:', team);
                }
            } catch (error) {
                console.error('Failed to change team color:', error);
            }
        }
        
        function updateTeamColorButtons(team) {
            const blueBtn = document.getElementById('teamBlueBtn');
            const orangeBtn = document.getElementById('teamOrangeBtn');
            
            if (team === 'Blue') {
                blueBtn.style.border = '2px solid white';
                orangeBtn.style.border = 'none';
            } else {
                orangeBtn.style.border = '2px solid white';
                blueBtn.style.border = 'none';
            }
        }
        
        // ============ TWITCH SETTINGS ============
        async function loadTwitchSettings() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_twitch_settings');
                const data = await response.json();
                
                document.getElementById('twitchEnabledCheck').checked = data.enabled || false;
                document.getElementById('twitchChannelInput').value = data.channel || '';
                document.getElementById('twitchOauthInput').value = data.oauth || '';
                
                console.log('[TWITCH] Settings loaded:', data);
            } catch (error) {
                console.error('Failed to load Twitch settings:', error);
            }
        }
        
        async function toggleTwitchEnabled() {
            const enabled = document.getElementById('twitchEnabledCheck').checked;
            
            try {
                const response = await fetch(`http://127.0.0.1:7862/api/set_twitch_enabled/${enabled}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log('[TWITCH] Enabled:', enabled);
                }
            } catch (error) {
                console.error('Failed to toggle Twitch:', error);
            }
        }
        
        async function saveTwitchSettings() {
            const enabled = document.getElementById('twitchEnabledCheck').checked;
            const channel = document.getElementById('twitchChannelInput').value.trim();
            const oauth = document.getElementById('twitchOauthInput').value.trim();
            
            if (!channel || !oauth) {
                alert('Please enter both channel name and OAuth token!');
                return;
            }
            
            try {
                const encodedChannel = encodeURIComponent(channel);
                const encodedOauth = encodeURIComponent(oauth);
                const response = await fetch(`http://127.0.0.1:7862/api/set_twitch_settings/${encodedChannel}/${encodedOauth}/${enabled}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    alert('‚úÖ Twitch settings saved! Restart the app to apply changes.');
                    console.log('[TWITCH] Settings saved successfully');
                } else {
                    alert('‚ùå Failed to save Twitch settings');
                }
            } catch (error) {
                console.error('Failed to save Twitch settings:', error);
                alert('‚ùå Error saving Twitch settings');
            }
        }
        
        async function loadOllamaModels() {
            try {
                const data = await safeFetch('http://127.0.0.1:7862/api/get_ollama_models', { method: 'GET' }, 3, 300);
                
                const selector = document.getElementById('ollamaModelSelector');
                selector.innerHTML = '';
                
                data.models.forEach(m => {
                    const option = document.createElement('option');
                    option.value = m;
                    option.textContent = m;
                    if (m === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load Ollama models:', error);
            }
        }
        
        async function changeOllamaModel() {
            const selector = document.getElementById('ollamaModelSelector');
            const model = selector.value;
            
            if (!model || model === 'Loading...') return;
            
            try {
                const encodedModel = encodeURIComponent(model);
                const response = await fetch(`http://127.0.0.1:7862/api/set_ollama_model/${encodedModel}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Ollama model changed to: ${model}`);
                } else {
                    console.error('Failed to change Ollama model:', data.message);
                }
            } catch (error) {
                console.error('Failed to change Ollama model:', error);
            }
        }
        
        async function loadAIProvider() {
            try {
                console.log('[OVERLAY] Loading AI provider...');
                const response = await fetch('http://127.0.0.1:7862/api/get_ai_provider');
                console.log(`[OVERLAY] get_ai_provider response status: ${response.status}`);
                const data = await response.json();
                console.log(`[OVERLAY] get_ai_provider response data:`, data);
                
                const selector = document.getElementById('aiProviderSelector');
                if (selector) {
                    // Temporarily remove onchange to prevent triggering during load
                    const originalOnChange = selector.onchange;
                    selector.onchange = null;
                    selector.value = data.ai_provider || 'echo_ai';
                    // Restore onchange after a short delay
                    setTimeout(() => {
                        selector.onchange = originalOnChange;
                    }, 100);
                    console.log(`‚úì AI provider loaded: ${selector.value} (from API: ${data.ai_provider})`);
                } else {
                    console.error('AI provider selector not found!');
                }
            } catch (error) {
                console.error('Failed to load AI provider:', error);
            }
        }
        
        async function changeAIProvider() {
            const selector = document.getElementById('aiProviderSelector');
            const provider = selector.value;
            
            console.log(`[OVERLAY] changeAIProvider called`);
            console.log(`[OVERLAY] selector exists: ${!!selector}`);
            console.log(`[OVERLAY] provider value: '${provider}'`);
            console.log(`[OVERLAY] provider type: ${typeof provider}`);
            
            if (!provider) {
                console.error('[OVERLAY] Failed to change AI provider: provider is empty/undefined');
                return;
            }
            
            try {
                const encodedProvider = encodeURIComponent(provider);
                console.log(`[OVERLAY] encoded provider: '${encodedProvider}'`);
                const url = `http://127.0.0.1:7862/api/set_ai_provider/${encodedProvider}`;
                console.log(`[OVERLAY] API URL: ${url}`);
                
                const response = await fetch(url);
                console.log(`[OVERLAY] API response status: ${response.status}`);
                const data = await response.json();
                console.log(`[OVERLAY] API response data:`, data);
                
                if (data.status === 'success') {
                    console.log(`‚úì AI provider changed to: ${provider}`);
                    // Reload dependent settings
                    loadPersonalities();
                    loadOllamaModels();
                    loadPollinationsModels();
                    loadPollinationsVoices();
                } else {
                    console.error('Failed to change AI provider:', data.message);
                }
            } catch (error) {
                console.error('Failed to change AI provider:', error);
            }
        }
        
        async function loadPollinationsModels() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_pollinations_models');
                const data = await response.json();
                
                const selector = document.getElementById('pollinationsModelSelector');
                selector.innerHTML = '';
                
                data.models.forEach(m => {
                    const option = document.createElement('option');
                    option.value = m.name;
                    option.textContent = m.description;
                    if (m.name === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load Pollinations models:', error);
            }
        }
        
        async function changePollinationsModel() {
            const selector = document.getElementById('pollinationsModelSelector');
            const model = selector.value;
            
            if (!model || model === 'Loading...') return;
            
            try {
                const encodedModel = encodeURIComponent(model);
                const response = await fetch(`http://127.0.0.1:7862/api/set_pollinations_model/${encodedModel}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Pollinations model changed to: ${model}`);
                } else {
                    console.error('Failed to change Pollinations model:', data.message);
                }
            } catch (error) {
                console.error('Failed to change Pollinations model:', error);
            }
        }
        
        async function loadPollinationsVoices() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_pollinations_voices');
                const data = await response.json();
                
                const selector = document.getElementById('pollinationsVoiceSelector');
                selector.innerHTML = '';
                
                data.voices.forEach(v => {
                    const option = document.createElement('option');
                    option.value = v;
                    option.textContent = v;
                    if (v === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load Pollinations voices:', error);
            }
        }
        
        async function changePollinationsVoice() {
            const selector = document.getElementById('pollinationsVoiceSelector');
            const voice = selector.value;
            
            if (!voice || voice === 'Loading...') return;
            
            try {
                const encodedVoice = encodeURIComponent(voice);
                const response = await fetch(`http://127.0.0.1:7862/api/set_pollinations_voice/${encodedVoice}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Pollinations voice changed to: ${voice}`);
                } else {
                    console.error('Failed to change Pollinations voice:', data.message);
                }
            } catch (error) {
                console.error('Failed to change Pollinations voice:', error);
            }
        }
        
        async function loadVisualization() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_visualization');
                const data = await response.json();
                
                document.getElementById('showTrackingCheck').checked = data.show_tracking;
                document.getElementById('enableBallTrailCheck').checked = data.enable_ball_trail;
                document.getElementById('trailLengthSlider').value = data.trail_length;
                document.getElementById('trailLengthValue').textContent = data.trail_length;
                document.getElementById('trailStyleSelect').value = data.trail_style;
            } catch (error) {
                console.error('Failed to load visualization settings:', error);
            }
        }
        
        async function updateVisualization() {
            const showTracking = document.getElementById('showTrackingCheck').checked;
            const enableBallTrail = document.getElementById('enableBallTrailCheck').checked;
            const trailLength = document.getElementById('trailLengthSlider').value;
            const trailStyle = document.getElementById('trailStyleSelect').value;
            
            document.getElementById('trailLengthValue').textContent = trailLength;
            
            try {
                const params = new URLSearchParams({
                    show_tracking: showTracking,
                    enable_ball_trail: enableBallTrail,
                    trail_length: trailLength,
                    trail_style: trailStyle
                });
                
                const response = await fetch(`http://127.0.0.1:7862/api/set_visualization/${params.toString()}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log('‚úì Visualization settings updated');
                }
            } catch (error) {
                console.error('Failed to update visualization settings:', error);
            }
        }
        
        function closeSettings() {
            document.getElementById('settingsPanel').style.display = 'none';
            
            // Make overlay unfocusable again
            if (typeof require !== 'undefined') {
                const { ipcRenderer } = require('electron');
                ipcRenderer.send('settings-panel-closed');
            }
        }
        
        // ============================================================
        //                   DISPLAY SOURCE SELECTION
        // ============================================================
        async function changeDisplaySource() {
            const selector = document.getElementById('displaySourceSelector');
            const source = selector.value;
            
            if (!source) return;
            
            try {
                const response = await fetch(`http://127.0.0.1:7862/api/set_display_source/${encodeURIComponent(source)}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log(`‚úì Display source changed to: ${source}`);
                } else {
                    console.error('Failed to change display source:', data.message);
                }
            } catch (error) {
                console.error('Failed to change display source:', error);
            }
        }
        
        // ============================================================
        //                   IMAGE MODE FUNCTIONS
        // ============================================================
        let imageModeEnabled = false;
        let currentBackgroundImage = null;
        
        async function toggleImageMode() {
            imageModeEnabled = !imageModeEnabled;
            const btn = document.getElementById('imageModeBtn');
            const promptContainer = document.getElementById('imagePromptContainer');
            
            if (imageModeEnabled) {
                btn.textContent = 'üé® Disable Image Mode';
                btn.style.background = '#8B00FF';
                promptContainer.style.display = 'block';
                console.log('‚úì Image Mode ENABLED - AI will generate art');
                
                // Notify backend
                try {
                    await fetch('http://127.0.0.1:7862/api/set_image_mode/true');
                } catch (error) {
                    console.error('Failed to enable image mode:', error);
                }
            } else {
                btn.textContent = 'üé® Enable Image Mode';
                btn.style.background = '#666';
                promptContainer.style.display = 'none';
                console.log('‚úì Image Mode DISABLED - overlay back to transparent');
                
                // Clear background image
                clearBackgroundImage();
                
                // Notify backend
                try {
                    await fetch('http://127.0.0.1:7862/api/set_image_mode/false');
                } catch (error) {
                    console.error('Failed to disable image mode:', error);
                }
            }
        }
        
        async function generateImageNow() {
            const input = document.getElementById('imagePromptInput');
            const prompt = input.value.trim();
            
            if (!prompt) {
                alert('Please enter a description for the artwork!');
                return;
            }
            
            try {
                console.log(`üé® Generating image: "${prompt}"`);
                const response = await fetch('http://127.0.0.1:7862/api/generate_image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ prompt: prompt })
                });
                
                console.log(`[IMAGE] Response status: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[IMAGE] HTTP error: ${response.status} - ${errorText}`);
                    alert(`Failed to generate image: HTTP ${response.status}`);
                    return;
                }
                
                const data = await response.json();
                console.log('[IMAGE] Response data:', data);
                
                if (data.status === 'success' && data.image_url) {
                    console.log(`‚úì Image generated: ${data.image_url}`);
                    setBackgroundImage(data.image_url);
                    input.value = ''; // Clear input
                } else {
                    const errorMsg = data.message || data.error || 'Unknown error';
                    console.error('Failed to generate image:', errorMsg);
                    alert(`Failed to generate image: ${errorMsg}`);
                }
            } catch (error) {
                console.error('Failed to generate image:', error);
                alert(`Failed to generate image: ${error.message || error}`);
            }
        }
        
        function setBackgroundImage(imageUrl) {
            currentBackgroundImage = imageUrl;
            document.body.style.backgroundImage = `url("${imageUrl}")`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundPosition = 'center center';
            document.body.style.backgroundRepeat = 'no-repeat';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.width = '100vw';
            document.body.style.height = '100vh';
            console.log(`üñºÔ∏è Background image set: ${imageUrl}`);
        }
        
        function clearBackgroundImage() {
            currentBackgroundImage = null;
            document.body.style.backgroundImage = 'none';
            document.body.style.background = 'transparent';
            document.body.style.backgroundAttachment = '';
            console.log('üóëÔ∏è Background image cleared - overlay transparent');
        }
        
        // Auto-generate image based on conversation context
        async function autoGenerateImage(userMessage, aiResponse) {
            if (!imageModeEnabled) {
                console.log('[IMAGE] Skipped: Image mode is not enabled');
                return;
            }
            
            if (!userMessage || !aiResponse) {
                console.error('[IMAGE] Skipped: Missing user message or AI response', {userMessage, aiResponse});
                return;
            }
            
            // Extract keywords and context from conversation
            const conversationContext = `${userMessage}. ${aiResponse}`;
            
            // Generate image prompt based on conversation
            // Use AI to extract visual concepts from the conversation
            try {
                console.log('üé® Auto-generating art based on conversation...');
                console.log('[IMAGE] User:', userMessage.substring(0, 50) + '...');
                console.log('[IMAGE] AI:', aiResponse.substring(0, 50) + '...');
                
                const response = await fetch('http://127.0.0.1:7862/api/auto_generate_image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_message: userMessage,
                        ai_response: aiResponse
                    })
                });
                
                if (!response.ok) {
                    console.error(`[IMAGE] HTTP error: ${response.status}`);
                    return;
                }
                
                const data = await response.json();
                
                if (data.status === 'success' && data.image_url) {
                    console.log(`‚úì Auto-generated image: ${data.image_url}`);
                    console.log(`üìù Image prompt: ${data.prompt}`);
                    setBackgroundImage(data.image_url);
                } else {
                    console.error('[IMAGE] Failed:', data.error || 'No image URL returned');
                }
            } catch (error) {
                console.error('Failed to auto-generate image:', error);
            }
        }
        
        let clickThroughEnabled = false;
        let commentaryEnabled = false;
        let voiceChatEnabled = false;
        
        function toggleClickThrough() {
            clickThroughEnabled = !clickThroughEnabled;
            const btn = document.getElementById('clickThroughBtn');
            
            if (clickThroughEnabled) {
                // Enable click-through
                document.querySelectorAll('.toggle-btn, #settingsPanel, .drag-handle').forEach(el => {
                    el.style.display = 'none';
                });
                document.getElementById('statusContainer').style.opacity = '0.5';
                btn.textContent = 'Disable Click-Through';
                
                // Tell Electron to ignore mouse events
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('toggle-click-through', true);
                }
                
                console.log('‚úì Click-through ENABLED - clicks pass through overlay');
            } else {
                // Disable click-through
                document.querySelectorAll('.toggle-btn, .drag-handle').forEach(el => {
                    el.style.display = 'block';
                });
                document.getElementById('statusContainer').style.opacity = '1';
                btn.textContent = 'Enable Click-Through';
                
                // Tell Electron to capture mouse events
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('toggle-click-through', false);
                }
                
                console.log('‚úì Click-through DISABLED - overlay is interactive');
            }
        }

        async function toggleCommentary() {
            const btn = document.getElementById('commentaryBtn');
            btn.disabled = true;
            
            try {
                const endpoint = commentaryEnabled ? 
                    'http://127.0.0.1:7862/api/stop_commentary' : 
                    'http://127.0.0.1:7862/api/start_commentary';
                
                const response = await fetch(endpoint);
                const data = await response.json();
                
                if (data.active !== undefined) {
                    commentaryEnabled = data.active;
                    
                    if (commentaryEnabled) {
                        btn.style.background = '#FF0000';
                        btn.textContent = '‚è∏ Stop Commentary';
                        console.log('‚úì AI commentary started');
                    } else {
                        btn.style.background = '#00AA00';
                        btn.textContent = '‚ñ∂ Start Commentary';
                        console.log('‚úì AI commentary stopped');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle commentary:', error);
            } finally {
                btn.disabled = false;
            }
        }

        async function toggleVoiceChat() {
            const btn = document.getElementById('voiceChatBtn');
            btn.disabled = true;
            
            try {
                const endpoint = voiceChatEnabled ? 
                    'http://127.0.0.1:7862/api/stop_voice' : 
                    'http://127.0.0.1:7862/api/start_voice';
                
                const response = await fetch(endpoint);
                const data = await response.json();
                
                if (data.active !== undefined) {
                    voiceChatEnabled = data.active;
                    
                    if (voiceChatEnabled) {
                        btn.style.background = '#FF6600';
                        btn.textContent = '‚è∏ Stop Voice Chat';
                        console.log('‚úì Voice chat started');
                    } else {
                        btn.style.background = '#0088FF';
                        btn.textContent = '‚ñ∂ Start Voice Chat';
                        console.log('‚úì Voice chat stopped');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle voice chat:', error);
            } finally {
                btn.disabled = false;
            }
        }

        // ============================================================
        //                   CHAT MODE TOGGLE (TEXT/IMAGE)
        // ============================================================
        let chatInImageMode = false;
        let mainChatInImageMode = false;
        
        // Toggle for settings panel chat input
        function toggleChatMode() {
            chatInImageMode = !chatInImageMode;
            const btn = document.getElementById('chatModeBtn');
            const input = document.getElementById('textChatInput');
            const hint = document.getElementById('chatModeHint');
            
            if (chatInImageMode) {
                // Switch to image mode
                btn.textContent = 'üé®';
                btn.style.background = '#8B00FF';
                btn.title = 'Image mode active - Click to switch to Text mode';
                input.placeholder = 'Describe the artwork you want to generate...';
                hint.textContent = 'üé® Image mode - Describe art to generate';
                hint.style.color = '#BB88FF';
                console.log('‚úì Chat switched to IMAGE mode');
            } else {
                // Switch to text mode
                btn.textContent = 'üí¨';
                btn.style.background = '#666';
                btn.title = 'Text mode active - Click to switch to Image mode';
                input.placeholder = 'Type your question...';
                hint.textContent = 'üí¨ Text mode - Ask Echo AI anything';
                hint.style.color = '#aaa';
                console.log('‚úì Chat switched to TEXT mode');
            }
        }
        
        // Toggle for main chat box at bottom
        function toggleMainChatMode() {
            mainChatInImageMode = !mainChatInImageMode;
            const btn = document.getElementById('mainChatModeBtn');
            const input = document.getElementById('chatInputField');
            const chatBox = document.getElementById('chatInputBox');
            
            if (mainChatInImageMode) {
                // Switch to image mode
                btn.textContent = 'üé®';
                btn.style.background = '#8B00FF';
                btn.title = 'Image mode - Click to switch to Text mode';
                input.placeholder = 'Describe the artwork to generate...';
                chatBox.style.borderColor = 'rgba(139, 0, 255, 0.8)';
                console.log('‚úì Main chat switched to IMAGE mode');
            } else {
                // Switch to text mode
                btn.textContent = 'üí¨';
                btn.style.background = '#666';
                btn.title = 'Text mode - Click to switch to Image mode';
                input.placeholder = 'Type to chat with Echo AI...';
                chatBox.style.borderColor = 'rgba(139, 0, 255, 0.6)';
                console.log('‚úì Main chat switched to TEXT mode');
            }
        }
        
        async function sendTextMessage() {
            const input = document.getElementById('textChatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // If in image mode, generate image instead of sending text
            if (chatInImageMode) {
                console.log(`üé® Generating image from chat: "${message}"`);
                input.value = ''; // Clear input immediately
                
                try {
                    const response = await fetch('http://127.0.0.1:7862/api/generate_image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ prompt: message })
                    });
                    
                    if (!response.ok) {
                        console.error(`[IMAGE] HTTP error: ${response.status}`);
                        return;
                    }
                    
                    const data = await response.json();
                    
                    if (data.status === 'success' && data.image_url) {
                        console.log(`‚úì Image generated from chat: ${data.image_url}`);
                        setBackgroundImage(data.image_url);
                    } else {
                        console.error('Failed to generate image:', data.error || data.message);
                    }
                } catch (error) {
                    console.error('Failed to generate image from chat:', error);
                }
                return;
            }
            
            // Normal text chat mode
            try {
                // Check for voice commands BEFORE sending to API
                detectVoiceCommand(message);
                
                // Show user's message in voice input card
                const voiceCard = document.getElementById('voiceInputCard');
                const voiceText = document.getElementById('voiceInputText');
                voiceText.textContent = message;
                voiceCard.style.display = 'block';
                
                // Clear input
                input.value = '';
                
                // Send to API
                const response = await fetch('http://127.0.0.1:7862/api/text_chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message: message })
                });
                
                const data = await response.json();
                
                if (data.response) {
                    // Show Echo's response in caption card with sentence-by-sentence timing (from sentences field)
                    addCaption(data.response, data.speaker || 'Echo AI', data.sentences);
                    console.log('‚úì Text chat response received');
                    
                    // Auto-generate image in image mode
                    if (imageModeEnabled) {
                        autoGenerateImage(message, data.response);
                    }
                } else {
                    console.error('No response from text chat');
                }
                
                // Hide user message after a delay
                setTimeout(() => {
                    voiceCard.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                console.error('Failed to send text message:', error);
                const voiceCard = document.getElementById('voiceInputCard');
                voiceCard.style.display = 'none';
            }
        }

        // Add Enter key support for text chat
        document.addEventListener('DOMContentLoaded', function() {
            const input = document.getElementById('textChatInput');
            if (input) {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendTextMessage();
                    }
                });
            }
        });

        function updateStatus(state, text) {
            const icon = document.getElementById('echoIcon');
            const statusText = document.getElementById('statusText');

            // Safety check
            if (!icon || !statusText) {
                console.warn('Status elements not found');
                return;
            }

            // Update state
            currentState = state;

            // Update icon and animation
            icon.className = 'echo-icon';

            switch(state) {
                case 'thinking':
                    icon.textContent = 'üß†';
                    icon.classList.add('thinking');
                    statusText.textContent = text || 'Thinking...';
                    break;
                case 'speaking':
                    icon.textContent = 'üó£Ô∏è';
                    icon.classList.add('speaking');
                    statusText.textContent = text || 'Speaking...';
                    break;
                case 'listening':
                    icon.textContent = 'üé§';
                    icon.classList.add('thinking');
                    statusText.textContent = text || 'Listening...';
                    break;
                case 'idle':
                default:
                    icon.textContent = '‚ö°';
                    statusText.textContent = 'Echo Ready';
                    break;
            }
        }

        async function showVoiceInput(text) {
            console.log('üé§ Voice input received:', text);
            
            // Detect voice commands from user's spoken input (animations only)
            detectVoiceCommand(text);
            
            const card = document.getElementById('voiceInputCard');
            const textEl = document.getElementById('voiceInputText');
            
            if (!card || !textEl) {
                console.error('Voice input elements not found!');
                return;
            }
            
            textEl.textContent = text;
            card.style.display = 'block';
            card.style.animation = 'slideInRight 0.3s ease-out';
            
            // Send to AI for a response (if text is substantive)
            if (text.length > 2) {
                try {
                    console.log('üì§ Sending voice input to AI:', text);
                    const response = await fetch('http://127.0.0.1:7862/api/text_chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ message: text })
                    });
                    
                    const data = await response.json();
                    
                    if (data.response) {
                        // Show Echo's response in caption card with sentence-by-sentence timing (from sentences field)
                        addCaption(data.response, data.speaker || 'Echo AI', data.sentences);
                        console.log('‚úì AI response received:', data.response);
                        
                        // Auto-generate image if image mode is enabled
                        if (imageModeEnabled) {
                            console.log('üñºÔ∏è Auto-generating image for voice chat response');
                            autoGenerateImage(text, data.response);
                        }
                    } else {
                        console.error('No response from text chat');
                    }
                } catch (error) {
                    console.error('Failed to get AI response:', error);
                }
            }
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                card.style.display = 'none';
            }, 10000);
        }

        let captionTimeout = null;
        let captionDuration = 10; // Default 10 seconds, adjustable via slider
        
        function updateCaptionDuration() {
            const slider = document.getElementById('captionDurationSlider');
            const valueDisplay = document.getElementById('captionDurationValue');
            captionDuration = parseInt(slider.value);
            valueDisplay.textContent = captionDuration + 's';
        }
        
        // Clean up AI response text - remove system prompts and debug text
        function cleanAIText(text) {
            if (!text) return text;
            
            let cleaned = text;
            
            // Remove [CHARACTER: ...] system prompt wrapper (everything before "Respond to this in character")
            cleaned = cleaned.replace(/\[CHARACTER:[\s\S]*?Respond to this in character[^\n]*:\s*/gi, '');
            
            // Remove common system prompt leakage patterns
            const systemPromptPatterns = [
                /You are \w+,.*?(?:\n|$)/gi,  // "You are Stoney, ..." at start
                /System:.*?(?:\n|$)/gi,        // "System: ..." lines
                /\[System\].*?(?:\n|$)/gi,     // "[System] ..." lines
                /Assistant:.*?(?:\n|$)/gi,     // "Assistant: ..." lines
                /\[Assistant\].*?(?:\n|$)/gi,  // "[Assistant] ..." lines
                /\[CHARACTER:.*?\]/gi,         // Any remaining [CHARACTER: ...] tags
            ];
            
            systemPromptPatterns.forEach(pattern => {
                cleaned = cleaned.replace(pattern, '');
            });
            
            // Remove leading/trailing prompt artifacts
            cleaned = cleaned.replace(/^(User:|Human:|AI:|Bot:)\s*/gi, '');
            
            // Uncensor common censored words (optional - remove if you want to keep censoring)
            const uncensorMap = {
                'f\\*ck': 'fuck',
                'f\\*\\*k': 'fuck',
                'sh\\*t': 'shit',
                's\\*\\*t': 'shit',
                'b\\*tch': 'bitch',
                'a\\*s': 'ass',
                'd\\*mn': 'damn',
                'h\\*ll': 'hell',
                'p\\*ss': 'piss',
                'c\\*nt': 'cunt'
            };
            
            Object.keys(uncensorMap).forEach(censored => {
                const regex = new RegExp(censored, 'gi');
                cleaned = cleaned.replace(regex, uncensorMap[censored]);
            });
            
            // Trim extra whitespace
            cleaned = cleaned.trim();
            
            // Remove any remaining consecutive newlines (keep max 2)
            cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
            
            return cleaned;
        }
        
        let sentenceTimeouts = [];
        
        function addCaption(text, speaker, sentences) {
            // Clean the text before displaying
            const cleanedText = cleanAIText(text);
            
            console.log('üì¢ Caption received:', cleanedText, 'Speaker:', speaker);
            if (text !== cleanedText) {
                console.log('   ‚ö†Ô∏è Text was cleaned (original had system prompts or censoring)');
            }
            
            const card = document.getElementById('captionCard');
            const textEl = document.getElementById('captionText');
            if (!card || !textEl) {
                console.error('Caption elements not found!');
                return;
            }
            
            // Clear any existing sentence timers
            sentenceTimeouts.forEach(t => clearTimeout(t));
            sentenceTimeouts = [];
            if (captionTimeout) {
                clearTimeout(captionTimeout);
            }
            
            // If we have sentence timings, display them sequentially
            if (sentences && sentences.length > 0) {
                console.log(`[CAPTION] Displaying ${sentences.length} sentences sequentially`);
                let currentSentenceIndex = 0;
                
                function showNextSentence() {
                    if (currentSentenceIndex >= sentences.length) {
                        // All sentences shown, hide card after last sentence duration + buffer
                        const lastSentence = sentences[sentences.length - 1];
                        captionTimeout = setTimeout(() => {
                            card.style.display = 'none';
                        }, (lastSentence.duration * 1000) + 500);
                        return;
                    }
                    
                    const sentence = sentences[currentSentenceIndex];
                    const cleanedSentence = cleanAIText(sentence.text);
                    
                    textEl.textContent = cleanedSentence;
                    if (currentSentenceIndex === 0) {
                        card.style.display = 'block';
                        card.style.animation = 'slideInRight 0.3s ease-out';
                    }
                    
                    console.log(`[CAPTION] Sentence ${currentSentenceIndex + 1}/${sentences.length}: "${cleanedSentence}" (${sentence.duration.toFixed(2)}s)`);
                    
                    currentSentenceIndex++;
                    
                    // Schedule next sentence
                    if (currentSentenceIndex < sentences.length) {
                        const timeout = setTimeout(showNextSentence, sentence.duration * 1000);
                        sentenceTimeouts.push(timeout);
                    } else {
                        showNextSentence(); // Call once more to hide card
                    }
                }
                
                showNextSentence();
            } else {
                // Fallback to old behavior if no sentence timings
                textEl.textContent = cleanedText;
                card.style.display = 'block';
                card.style.animation = 'slideInRight 0.3s ease-out';
                captionTimeout = setTimeout(() => {
                    card.style.display = 'none';
                }, captionDuration * 1000);
            }
        }

        function drawTracking(data) {
            // Clear canvas
            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            
            if (!data.show_tracking || !data.tracking_data || !data.tracking_data.detections) {
                return;
            }
            
            const trackingData = data.tracking_data;
            const [gameW, gameH] = trackingData.resolution || [1920, 1080];
            
            // Scale factors to map game coordinates to overlay canvas
            const scaleX = trackingCanvas.width / gameW;
            const scaleY = trackingCanvas.height / gameH;
            
            // Debug logging (only log occasionally to avoid spam)
            if (Math.random() < 0.01) {
                console.log(`Tracking: Game=${gameW}x${gameH}, Canvas=${trackingCanvas.width}x${trackingCanvas.height}, Scale=(${scaleX.toFixed(2)}, ${scaleY.toFixed(2)})`);
            }
            
            // Draw detection boxes
            trackingData.detections.forEach(det => {
                const [x1, y1, x2, y2] = det.box;
                const sx1 = x1 * scaleX;
                const sy1 = y1 * scaleY;
                const sx2 = x2 * scaleX;
                const sy2 = y2 * scaleY;
                
                // Color code by type
                let color = '#FFFFFF';
                if (det.type === 'ball') color = '#00FF00';
                else if (det.type === 'my_goal') color = '#0088FF';
                else if (det.type === 'enemy_goal') color = '#FF0088';
                else if (det.type === 'teammate') color = '#00FFFF';
                else if (det.type === 'enemy') color = '#FF4444';
                
                trackingCtx.strokeStyle = color;
                trackingCtx.lineWidth = 3;
                trackingCtx.strokeRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
                
                // Label
                trackingCtx.fillStyle = color;
                trackingCtx.font = '14px Arial';
                trackingCtx.fillText(`${det.type} (${(det.conf * 100).toFixed(0)}%)`, sx1, sy1 - 5);
            });
            
            // Draw ball trail
            if (data.ball_trail_enabled && trackingData.trail_points && trackingData.trail_points.length > 1) {
                trackingCtx.lineCap = 'round';
                trackingCtx.lineJoin = 'round';
                
                for (let i = 1; i < trackingData.trail_points.length; i++) {
                    const pt1 = trackingData.trail_points[i - 1];
                    const pt2 = trackingData.trail_points[i];
                    
                    const alpha = i / trackingData.trail_points.length;
                    const thickness = 2 + alpha * 4;
                    
                    trackingCtx.beginPath();
                    trackingCtx.moveTo(pt1[0] * scaleX, pt1[1] * scaleY);
                    trackingCtx.lineTo(pt2[0] * scaleX, pt2[1] * scaleY);
                    
                    // Trail style colors
                    if (data.trail_style === 'rainbow') {
                        const hue = (i / trackingData.trail_points.length) * 360;
                        trackingCtx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                    } else if (data.trail_style === 'glow') {
                        trackingCtx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                    } else if (data.trail_style === 'fade') {
                        trackingCtx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    } else { // solid
                        trackingCtx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    }
                    
                    trackingCtx.lineWidth = thickness;
                    trackingCtx.stroke();
                }
            }
        }

        // Poll the Python backend for status updates
        let pollingInterval;
        let lastCaptionText = '';
        let lastVoiceInput = '';  // Track last voice input to prevent duplicates
        let lastImageUrl = '';  // Track last image URL to prevent duplicate updates
        let connectionErrors = 0;
        let serverPort = 7862;  // API server port (separate from Gradio)
        let portCheckAttempts = 0;
        
        // Chat box drag functionality
        let chatBoxDragging = false;
        let chatBoxOffsetX = 0;
        let chatBoxOffsetY = 0;
        
        function initChatBoxDrag() {
            const chatBox = document.getElementById('chatInputBox');
            if (!chatBox) return;
            
            chatBox.addEventListener('mousedown', function(e) {
                // Only drag if clicking on the box itself, not input or buttons
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
                    // Make overlay focusable when interacting with input
                    if (typeof require !== 'undefined') {
                        const { ipcRenderer } = require('electron');
                        ipcRenderer.send('chat-box-focused');
                    }
                    return;
                }
                
                chatBoxDragging = true;
                const rect = chatBox.getBoundingClientRect();
                chatBoxOffsetX = e.clientX - rect.left;
                chatBoxOffsetY = e.clientY - rect.top;
                chatBox.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!chatBoxDragging) return;
                
                const chatBox = document.getElementById('chatInputBox');
                const x = e.clientX - chatBoxOffsetX;
                const y = e.clientY - chatBoxOffsetY;
                
                chatBox.style.left = x + 'px';
                chatBox.style.top = y + 'px';
                chatBox.style.transform = 'none';
            });
            
            document.addEventListener('mouseup', function() {
                if (chatBoxDragging) {
                    chatBoxDragging = false;
                    const chatBox = document.getElementById('chatInputBox');
                    chatBox.style.cursor = 'move';
                }
            });
        }
        
        function toggleChatBox() {
            const chatBox = document.getElementById('chatInputBox');
            if (chatBox.style.display === 'none') {
                chatBox.style.display = 'block';
            } else {
                chatBox.style.display = 'none';
                
                // Make overlay unfocusable when closing chat box
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('chat-box-blurred');
                }
            }
        }
        
        async function sendChatMessage() {
            const input = document.getElementById('chatInputField');
            const message = input.value.trim();
            
            if (!message) return;
            
            // If in image mode, generate image instead of sending text
            if (mainChatInImageMode) {
                console.log(`üé® Generating image from main chat: "${message}"`);
                input.value = ''; // Clear input immediately
                input.blur();
                
                try {
                    const response = await fetch('http://127.0.0.1:7862/api/generate_image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ prompt: message })
                    });
                    
                    if (!response.ok) {
                        console.error(`[IMAGE] HTTP error: ${response.status}`);
                        return;
                    }
                    
                    const data = await response.json();
                    
                    if (data.status === 'success' && data.image_url) {
                        console.log(`‚úì Image generated from main chat: ${data.image_url}`);
                        setBackgroundImage(data.image_url);
                    } else {
                        console.error('Failed to generate image:', data.error || data.message);
                    }
                } catch (error) {
                    console.error('Failed to generate image from main chat:', error);
                }
                return;
            }
            
            // Normal text chat mode
            try {
                // Show user's message in voice input card
                const voiceCard = document.getElementById('voiceInputCard');
                const voiceText = document.getElementById('voiceInputText');
                voiceText.textContent = message;
                voiceCard.style.display = 'block';
                
                // Clear input and blur it to make overlay unfocusable
                input.value = '';
                input.blur();
                
                // Make overlay unfocusable after sending
                if (typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    ipcRenderer.send('chat-box-blurred');
                }
                
                // Send to API
                const response = await fetch('http://127.0.0.1:7862/api/text_chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });
                
                const data = await response.json();
                
                if (data.response) {
                    console.log('‚úì Chat response received');
                }
                
                // Hide user message after a delay
                setTimeout(() => {
                    voiceCard.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                console.error('Failed to send chat message:', error);
            }
        }

        // Wait for server health endpoint indicating warmup readiness
        async function waitForHealthReady(timeoutMs = 30000, interval = 1000) {
            const start = Date.now();
            console.log('[OVERLAY] Polling /api/health for readiness...');
            while (Date.now() - start < timeoutMs) {
                try {
                    const url = `http://127.0.0.1:${serverPort}/api/health`;
                    const data = await safeFetch(url, { method: 'GET', cache: 'no-cache' }, 0, 100);
                    if (data && (data.ready === true || data.status === 'ok' && data.ready)) {
                        console.log('[OVERLAY] /api/health reports ready:', data);
                        return true;
                    }
                    console.log('[OVERLAY] /api/health not ready yet, retrying...');
                } catch (e) {
                    console.warn('[OVERLAY] health check failed:', e && e.message ? e.message : e);
                }
                await new Promise(r => setTimeout(r, interval));
            }
            console.warn('[OVERLAY] /api/health readiness timed out');
            return false;
        }

        // Try multiple ports to find the server
        async function findServerPort() {
            const portsToTry = [7862, 7860, 7861, 7863, 7864, 7865];  // Try 7862 first
            
            console.log('üîç Searching for PLAIX server...');
            console.log('Current URL:', window.location.href);
            
            for (let port of portsToTry) {
                try {
                    const url = `http://127.0.0.1:${port}/api/overlay_status`;
                    console.log(`Trying ${url}...`);
                    
                    // Create manual timeout controller
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    try {
                        const data = await safeFetch(url, { signal: controller.signal, mode: 'cors' }, 0, 100);
                        clearTimeout(timeoutId);
                        console.log(`Port ${port} data:`, data);
                        serverPort = port;
                        console.log(`‚úì‚úì‚úì Found server on port ${port}`);
                        document.getElementById('connectionStatus').innerHTML = `üü¢ Connected (port ${port})`;
                        document.getElementById('connectionStatus').style.color = '#00ff00';
                        connectionErrors = 0;
                        return true;
                    } catch (err) {
                        clearTimeout(timeoutId);
                        console.error(`Port ${port} error:`, err && err.name ? err.name : err);
                    }
                } catch (err) {
                    console.error(`Port ${port} error:`, err.name, err.message);
                    // Try next port
                }
            }
            
            console.log('‚ö†Ô∏è Server not found on any port, will retry...');
            document.getElementById('connectionStatus').innerHTML = 'üü° Waiting for server...';
            document.getElementById('connectionStatus').style.color = '#ffaa00';
            return false;
        }

        async function pollStatus() {
            try {
                    const data = await safeFetch(`http://127.0.0.1:${serverPort}/api/overlay_status`, { method: 'GET', cache: 'no-cache' }, 2, 200);
                                        
                    // Bail out early if server returned nothing
                    if (!data) {
                        connectionErrors++;
                        if (connectionErrors > 5) {
                            document.getElementById('connectionStatus').innerHTML = 'üî¥ Server Error';
                            document.getElementById('connectionStatus').style.color = '#ff0000';
                        }
                        return;
                    }

                    // Reset connection errors on success
                    if (connectionErrors > 0) {
                        connectionErrors = 0;
                        document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected';
                        document.getElementById('connectionStatus').style.color = '#00ff00';
                    }
                    
                    // Update status if changed
                    if (data.state !== currentState) {
                        updateStatus(data.state, data.status_text);
                    }

                    // Show voice input (what user said) - only if changed to avoid duplicates
                    if (data.voice_input && data.voice_input.trim()) {
                        if (!lastVoiceInput || data.voice_input !== lastVoiceInput) {
                            showVoiceInput(data.voice_input);
                            lastVoiceInput = data.voice_input;
                        }
                    }

                    // Check for new generated image (from Twitch chat or other sources)
                    if (data.image_url && imageModeEnabled) {
                        if (!lastImageUrl || data.image_url !== lastImageUrl) {
                            console.log('üé® New image URL received:', data.image_url);
                            setBackgroundImage(data.image_url);
                            lastImageUrl = data.image_url;
                        }
                    }

                    // Add caption if new text (avoid duplicates)
                    if (data.caption_text && typeof data.caption_text === 'object' && data.caption_text.text && data.caption_text.text.trim()) {
                        if (!lastCaptionText || data.caption_text.text !== lastCaptionText) {
                            console.log('New caption detected:', data.caption_text);
                            addCaption(data.caption_text.text, data.caption_text.speaker, data.caption_text.sentences);
                            lastCaptionText = data.caption_text.text;
                            
                            // Debug: Check what phoneme data we have
                            console.log('[DEBUG] caption_text.phonemes?', !!data.caption_text.phonemes);
                            console.log('[DEBUG] root phonemes?', !!data.phonemes);
                            console.log('[DEBUG] Full data keys:', Object.keys(data));
                            
                            // Process phonemes for lip-sync - check both locations
                            let phonemes = data.caption_text.phonemes || data.phonemes;
                            if (phonemes && phonemes.length > 0) {
                                console.log('[LIP-SYNC] ‚úì Received ' + phonemes.length + ' phonemes');
                                console.log('[LIP-SYNC] First 3 phonemes:', phonemes.slice(0, 3));
                                startLipSync(phonemes);
                            } else {
                                console.log('[LIP-SYNC] ‚ùå No phonemes found in data');
                            }
                            
                            // Trigger animation based on event type
                            if (data.caption_text.event_type) {
                                console.log('[AVATAR] Event type detected:', data.caption_text.event_type);
                                triggerAnimationForEvent(data.caption_text.event_type);
                            }
                            
                            // Detect events and expressions from text content with comprehensive keywords
                            const text = data.caption_text.text.toLowerCase();
                            
                            // Goal detection - multiple triggers (HIGH PRIORITY - interrupt speech)
                            if (text.includes('goal!') || text.includes('scores!') || text.includes('goooal') || 
                                text.includes('in the net') || text.includes('what a strike') || 
                                text.includes('slammed into') || text.includes('finds the back of the net')) {
                                console.log('[AVATAR] üéâ Goal detected in text - celebrating immediately!');
                                triggerAnimationForEvent('goal_scored', true); // true = interrupt current animation
                            }
                            // Save detection
                            else if (text.includes('save!') || text.includes('epic save') || text.includes('what a save') ||
                                     text.includes('blocks it') || text.includes('stopped it') || text.includes('denied')) {
                                console.log('[AVATAR] üß§ Save detected in text - cheering!');
                                setTimeout(() => triggerAnimationForEvent('save'), 500);
                            }
                            // Shot detection - subtle reaction
                            else if (text.includes('shot') || text.includes('fires') || text.includes('rips it') ||
                                     text.includes('launches') || text.includes('mph')) {
                                console.log('[AVATAR] ‚ö° Shot detected - reacting!');
                                // Rotate to ball direction briefly
                                if (data.tracking_data && data.tracking_data.ball) {
                                    updateAvatarRotation(data.tracking_data.ball.x / data.tracking_data.frame_width);
                                }
                            }
                            
                            // Detect expressions from speech content for natural reactions
                            detectSpeechExpressions(text);
                            
                            // Update status to show Echo is active
                            if (document.getElementById('statusText').textContent === 'Waiting for server...') {
                                updateStatus('idle', 'Echo Ready');
                            }
                        }
                    } else if (data.caption_text === undefined) {
                        console.log('‚ö†Ô∏è No caption_text in server response:', data);
                    }
                    
                    // Draw tracking overlay
                    drawTracking(data);
                    
                    // Continuous ball tracking - update avatar rotation based on ball position
                    if (data.tracking_data && data.tracking_data.ball && continuousTrackingEnabled) {
                        const ballX = data.tracking_data.ball.x / (data.tracking_data.frame_width || 1920);
                        updateAvatarRotation(ballX);
                    }
                    
                    // Check for goal events from tracking data (high priority)
                    if (data.tracking_data && data.tracking_data.game_state) {
                        checkForGoalEvent(data.tracking_data.game_state);
                    }
                    
                    // Poll for avatar URL changes from personality selection
                    if (data.avatar_url && data.avatar_url !== currentAvatarPath) {
                        console.log('[AVATAR] New avatar URL detected from server:', data.avatar_url);
                        currentAvatarPath = data.avatar_url;
                        loadAvatarModel(data.avatar_url);
                    }
                    
                    // Poll for avatar window show request
                    if (data.show_avatar_window === true) {
                        console.log('[AVATAR] Show avatar window request detected');
                        const container = document.getElementById('avatarContainer');
                        if (container && container.style.display === 'none') {
                            toggleAvatarWindow();
                        }
                        // Clear the flag on backend
                        try {
                            await fetch('http://127.0.0.1:7862/api/clear_avatar_window_flag', { method: 'POST' });
                        } catch (e) {
                            console.error('[AVATAR] Failed to clear avatar window flag:', e);
                        }
                    }
                    
                    // Poll for content box display requests
                    if (data.content_box && data.content_box.action) {
                        const contentData = data.content_box;
                        if (contentData.action === 'show_image' && contentData.url) {
                            displayImage(contentData.url, contentData.title || 'üñºÔ∏è Image');
                        } else if (contentData.action === 'show_video' && contentData.url) {
                            displayVideo(contentData.url, contentData.title || 'üé• Video');
                        } else if (contentData.action === 'show_webpage' && contentData.url) {
                            displayWebpage(contentData.url, contentData.title || 'üåê Webpage');
                        } else if (contentData.action === 'show_html' && contentData.html) {
                            displayHTML(contentData.html, contentData.title || 'üìÑ Content');
                        } else if (contentData.action === 'open_window' && contentData.url) {
                            // Open URL in new Electron window (for sites that block iframes)
                            console.log('[CONTENT BOX] Opening in new window:', contentData.url);
                            const { ipcRenderer } = require('electron');
                            ipcRenderer.send('open-content-window', contentData.url, contentData.title || 'üåê Content');
                        } else if (contentData.action === 'hide') {
                            hideContentBox();
                        }
                        // Clear the flag on backend
                        try {
                            await fetch('http://127.0.0.1:7862/api/clear_content_box_flag', { method: 'POST' });
                        } catch (e) { console.warn('Failed to clear content box flag:', e); }
                    }

            } catch (err) {
                connectionErrors++;
                
                // Log detailed error every 100 attempts
                if (connectionErrors % 100 === 0) {
                    console.error(`‚ùå GET request failed (attempt ${connectionErrors}):`, err.message);
                    console.error('URL:', `http://127.0.0.1:${serverPort}/api/overlay_status`);
                }
                
                if (connectionErrors > 10) {
                    document.getElementById('connectionStatus').innerHTML = 'üü° Connecting...';
                    document.getElementById('connectionStatus').style.color = '#ffaa00';
                }
                
                // Try to find the server on a different port every 5 seconds
                if (connectionErrors % 50 === 0) {
                    console.log('Searching for server on alternate ports...');
                    findServerPort();
                }
            }
        }

        // Start polling when page loads
        window.addEventListener('load', async () => {
            console.log('üé® Overlay window loaded');
            updateStatus('idle', 'Initializing...');
            
            // Initialize animation library paths first
            console.log('üìÇ Initializing animation library...');
            await initializeAnimationLibrary();
            console.log('‚úì Animation library ready');
            
            // Try to find the server first with retry logic
            document.getElementById('connectionStatus').innerHTML = 'üü° Waiting for PLAIX server...';
            document.getElementById('connectionStatus').style.color = '#ffaa00';
            
            let serverFound = await findServerPort();
            
            // If not found initially, retry every 2 seconds for up to 30 seconds
            let retryCount = 0;
            while (!serverFound && retryCount < 15) {
                console.log(`Retry ${retryCount + 1}/15 in 2 seconds...`);
                await new Promise(resolve => setTimeout(resolve, 2000));
                serverFound = await findServerPort();
                retryCount++;
            }
            
            if (serverFound) {
                // Wait for /api/health to report ready (model warmup) before loading heavy resources
                const healthReady = await waitForHealthReady(30000, 1000);
                if (!healthReady) {
                    console.warn('[OVERLAY] Health check timed out ‚Äî proceeding but some features may be unavailable until models warm up');
                    document.getElementById('connectionStatus').innerHTML = 'üü° Connected (warming models...)';
                    updateStatus('thinking', 'Warming models...');
                } else {
                    document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected & Listening';
                    updateStatus('idle', 'Echo AI Ready');
                }

                // Always load essential config and YOLO models for overlay visuals
                await loadGameMode();
                await loadYoloModels();

                // Defer heavier AI/TTS/OLLAMA loads until healthReady to avoid parse/fetch errors during warmup
                if (healthReady) {
                    await Promise.all([
                        loadPersonalities(),
                        loadTTSEngines(),
                        loadVoices(),
                        loadOllamaModels(),
                        loadAIProvider(),
                        loadPollinationsModels(),
                        loadPollinationsVoices(),
                        loadVisualization()
                    ]);
                } else {
                    // Minimal load to keep overlay usable; try to load AI provider only
                    try { await loadAIProvider(); } catch (e) { console.warn('[OVERLAY] loadAIProvider failed while health warming:', e); }
                }

                console.log('‚úì Server connection established, starting polling');
                // Initialize chat box drag
                initChatBoxDrag();
                
                // Load overlay settings
                loadPlayerName();
                loadPersonalities();
                loadTTSEngines();
                loadVoices();
                loadTeamColor();
                loadTwitchSettings();
                loadOllamaModels();
                loadAIProvider();
                loadPollinationsModels();
                loadPollinationsVoices();
                loadVisualization();
                
                // Poll every 100ms for responsive updates
                pollingInterval = setInterval(pollStatus, 100);
                
                // Auto-load default avatar (male)
                console.log('üé≠ Auto-loading default avatar...');
                currentAvatarPath = avatarURLs['male-default'];
                showAndLoadAvatar(currentAvatarPath);
                
                // Auto-start voice chat first (1 second delay), then commentary if needed
                setTimeout(() => {
                    console.log('üé§ Auto-starting voice chat...');
                    toggleVoiceChat();
                }, 1000);
                
                // Optional: Auto-start commentary after 3 seconds (commented out by default)
                // setTimeout(() => {
                //     console.log('üé¨ Auto-starting commentary...');
                //     toggleCommentary();
                // }, 3000);
            } else {
                console.error('‚ùå Failed to connect to server after 30 seconds');
                document.getElementById('connectionStatus').innerHTML = 'üî¥ Server not found';
                document.getElementById('connectionStatus').style.color = '#ff0000';
                updateStatus('idle', 'Server Offline');
                
                // Still start polling in case server comes up later
                pollingInterval = setInterval(pollStatus, 1000); // Slower polling
            }
        });

        // --- Game Mode Sync ---
        async function loadGameMode() {
            try {
                const response = await fetch('http://127.0.0.1:7862/api/get_game_mode');
                const data = await response.json();
                const selector = document.getElementById('gameModeSelector');
                if (selector && data.game_mode) {
                    selector.value = data.game_mode;
                }
            } catch (error) {
                console.error('Failed to load game mode:', error);
            }
        }

        async function changeGameMode() {
            const selector = document.getElementById('gameModeSelector');
            const mode = selector.value;
            if (!mode) return;
            try {
                const encoded = encodeURIComponent(mode);
                const response = await fetch(`http://127.0.0.1:7862/api/set_game_mode/${encoded}`);
                const data = await response.json();
                if (data.status === 'success') {
                    console.log('‚úì Game mode changed to:', mode);
                    // Optionally reload personalities or UI here
                    loadPersonalities();
                } else {
                    console.error('Failed to change game mode:', data.error);
                }
            } catch (error) {
                console.error('Failed to change game mode:', error);
            }
        }

        // Expose as global
        window.loadGameMode = loadGameMode;
        window.changeGameMode = changeGameMode;

        // ============ INTERACTIVE CONTENT BOX SYSTEM ============
        let contentBoxVisible = false;

        function showContentBox(title = 'ü§ñ AI Content') {
            const box = document.getElementById('contentBox');
            const titleEl = document.getElementById('contentBoxTitle');
            titleEl.textContent = title;
            box.classList.add('visible');
            contentBoxVisible = true;
            console.log('[CONTENT BOX] Shown:', title);
        }

        function hideContentBox() {
            const box = document.getElementById('contentBox');
            box.classList.remove('visible');
            contentBoxVisible = false;
            console.log('[CONTENT BOX] Hidden');
        }

        function displayImage(imageUrl, title = 'üñºÔ∏è Image') {
            const content = document.getElementById('contentBoxContent');
            console.log('[CONTENT BOX] Displaying image:', imageUrl);
            
            // Create image with error handling
            content.innerHTML = `
                <div style="text-align: center;">
                    <img src="${imageUrl}" 
                         alt="AI displayed image" 
                         style="max-width: 100%; height: auto; display: block; margin: 0 auto;"
                         onload="console.log('[CONTENT BOX] ‚úì Image loaded successfully')"
                         onerror="this.style.display='none'; this.parentElement.innerHTML='<p style=color:red>‚ùå Failed to load image from: ${imageUrl}</p><p>URL may be blocked or unavailable</p>'; console.error('[CONTENT BOX] ‚úó Image failed to load:', '${imageUrl}')" />
                    <div style="margin-top: 10px; font-size: 12px; color: #888;">Loading image...</div>
                </div>
            `;
            showContentBox(title);
        }

        function displayVideo(videoUrl, title = 'üé• Video') {
            const content = document.getElementById('contentBoxContent');
            content.innerHTML = `
                <video controls autoplay>
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            `;
            showContentBox(title);
            console.log('[CONTENT BOX] Displaying video:', videoUrl);
        }

        function displayWebpage(url, title = 'üåê Webpage') {
            const content = document.getElementById('contentBoxContent');
            content.innerHTML = `<iframe src="${url}" sandbox="allow-scripts allow-same-origin"></iframe>`;
            showContentBox(title);
            console.log('[CONTENT BOX] Displaying webpage:', url);
        }

        function displayHTML(html, title = 'üìÑ Content') {
            const content = document.getElementById('contentBoxContent');
            content.innerHTML = html;
            showContentBox(title);
            console.log('[CONTENT BOX] Displaying HTML content');
        }

        // Test function for settings panel
        function testContentBox() {
            const testTypes = ['image', 'video', 'webpage'];
            const randomType = testTypes[Math.floor(Math.random() * testTypes.length)];
            
            if (randomType === 'image') {
                displayImage('https://picsum.photos/800/600', 'üñºÔ∏è Random Image');
            } else if (randomType === 'video') {
                displayHTML(`
                    <h3 style="color: #8B00FF; margin-bottom: 10px;">üé• Video Player</h3>
                    <p style="margin-bottom: 10px;">This would play a video. Try a YouTube URL or local video file!</p>
                    <div style="background: rgba(139, 0, 255, 0.2); padding: 20px; border-radius: 8px; text-align: center;">
                        <p style="font-size: 48px; margin: 20px 0;">‚ñ∂Ô∏è</p>
                        <p style="color: #aaa;">Video player ready</p>
                    </div>
                `, 'üé• Video Test');
            } else {
                displayWebpage('https://example.com', 'üåê Example Website');
            }
        }

        // ============ AVATAR SYSTEM ============
        let avatarScene, avatarCamera, avatarRenderer, avatarModel, avatarMixer, avatarClock;
        let morphTargetMeshes = [];
        let currentAvatarPath = null;
        let avatarDragging = false;
        let avatarDragOffset = { x: 0, y: 0 };
        
        const avatarURLs = {
            'male-default': 'src/stoney.glb',
            'female-default': 'src/sarax.glb'
        };

        function initAvatarScene() {
            const canvas = document.getElementById('avatarCanvas');
            if (!canvas || avatarRenderer) return; // Already initialized

            avatarScene = new THREE.Scene();
            avatarCamera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            avatarCamera.position.set(0, 1.6, 1.5);
            avatarCamera.lookAt(0, 1.5, 0);

            avatarRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            avatarRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
            avatarRenderer.setClearColor(0x000000, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            avatarScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 1);
            avatarScene.add(directionalLight);

            avatarClock = new THREE.Clock();

            // OrbitControls
            const controls = new THREE.OrbitControls(avatarCamera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.5, 0);
            controls.update();
            
            // Detect manual control to disable auto-rotation
            let manualControlActive = false;
            let manualControlTimeout = null;
            
            controls.addEventListener('start', () => {
                manualControlActive = true;
                console.log('[AVATAR] Manual control active - disabling ball tracking');
                clearTimeout(manualControlTimeout);
            });
            
            controls.addEventListener('end', () => {
                // Re-enable auto-rotation after 5 seconds of no interaction
                clearTimeout(manualControlTimeout);
                manualControlTimeout = setTimeout(() => {
                    manualControlActive = false;
                    console.log('[AVATAR] Manual control released - enabling ball tracking');
                }, 5000);
            });
            
            // Store controls globally for rotation checks
            window.avatarControls = controls;
            window.isManualControl = () => manualControlActive;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (avatarMixer) avatarMixer.update(avatarClock.getDelta());
                controls.update();
                avatarRenderer.render(avatarScene, avatarCamera);
            }
            animate();

            console.log('[AVATAR] Three.js scene initialized');
        }

        let idleAnimation = null;
        let currentAnimation = null;
        let phonemeQueue = [];
        let lipSyncInterval = null;
        
        // Animation library paths - dynamically resolved for packaged apps
        // Store paths globally once fetched
        let cachedAppPaths = null;
        
        const getAnimationPath = async (relativePath) => {
            try {
                // Get app paths from main process if not cached
                if (!cachedAppPaths && typeof require !== 'undefined') {
                    const { ipcRenderer } = require('electron');
                    cachedAppPaths = await ipcRenderer.invoke('get-app-paths');
                    console.log('App paths retrieved:', cachedAppPaths);
                }
                
                if (cachedAppPaths) {
                    // Use resourcesPath for packaged apps, appPath otherwise
                    const basePath = cachedAppPaths.resourcesPath || cachedAppPaths.appPath;
                    // Convert Windows backslashes to forward slashes for file:// URLs
                    const fullPath = `${basePath}/${relativePath}`.replace(/\\/g, '/');
                    console.log(`Animation path: file:///${fullPath}`);
                    return `file:///${encodeURI(fullPath)}`;
                }
            } catch (e) {
                console.warn('Could not get app paths via IPC, using fallback:', e);
            }
            
            // Fallback for dev mode: use window.location to determine base path
            // overlay.html is in electron/ folder, so go up one level to project root
            const currentPath = window.location.pathname;
            const electronDir = currentPath.substring(0, currentPath.lastIndexOf('/'));
            const projectRoot = electronDir.substring(0, electronDir.lastIndexOf('/'));
            const fullPath = `${projectRoot}/${relativePath}`.replace(/\\/g, '/');
            console.log(`Animation path (dev fallback): file://${fullPath}`);
            return `file://${encodeURI(fullPath)}`;
        };
        
        // Initialize animation library with resolved paths
        let animationLibrary = null;
        
        async function initializeAnimationLibrary() {
            const animations = {
                // Idle animations - multiple variations for variety
                idle: 'animation-library-master/masculine/glb/idle/M_Standing_Idle_001.glb',
                idle_casual: 'animation-library-master/masculine/glb/idle/M_Standing_Idle_002.glb',
                idle_var1: 'animation-library-master/masculine/glb/idle/M_Standing_Idle_Variations_001.glb',
                idle_var2: 'animation-library-master/masculine/glb/idle/M_Standing_Idle_Variations_002.glb',
                idle_var3: 'animation-library-master/masculine/glb/idle/M_Standing_Idle_Variations_003.glb',
                
                // Talking animations
                talking: 'animation-library-master/masculine/glb/expression/M_Talking_Variations_001.glb',
                talking2: 'animation-library-master/masculine/glb/expression/M_Talking_Variations_002.glb',
                talking3: 'animation-library-master/masculine/glb/expression/M_Talking_Variations_003.glb',
                
                // Expression animations
                happy: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_001.glb',
                excited: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_002.glb',
                surprised: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_004.glb',
                thinking: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_005.glb',
                frustrated: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_006.glb',
                laugh: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_007.glb',
                shrug: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_008.glb',
                point: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_009.glb',
                wave: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_010.glb',
                nod: 'animation-library-master/masculine/glb/expression/M_Standing_Expressions_011.glb',
                
                // Dance/Celebration animations
                dance: 'animation-library-master/masculine/glb/dance/M_Dances_001.glb',
                dance2: 'animation-library-master/masculine/glb/dance/M_Dances_002.glb',
                dance3: 'animation-library-master/masculine/glb/dance/M_Dances_003.glb',
                cheer: 'animation-library-master/masculine/glb/dance/M_Dances_005.glb',
                celebrate: 'animation-library-master/masculine/glb/dance/M_Dances_007.glb',
                victory: 'animation-library-master/masculine/glb/dance/M_Dances_008.glb',
                
                // Locomotion animations
                walk: 'animation-library-master/masculine/glb/locomotion/M_Walk_001.glb',
                walk_back: 'animation-library-master/masculine/glb/locomotion/M_Walk_Backwards_001.glb',
                jog: 'animation-library-master/masculine/glb/locomotion/M_Jog_001.glb',
                run: 'animation-library-master/masculine/glb/locomotion/M_Run_001.glb',
                jump: 'animation-library-master/masculine/glb/locomotion/M_Walk_Jump_001.glb',
                run_jump: 'animation-library-master/masculine/glb/locomotion/M_Run_Jump_001.glb',
                strafe_left: 'animation-library-master/masculine/glb/locomotion/M_Walk_Strafe_Left_002.glb',
                strafe_right: 'animation-library-master/masculine/glb/locomotion/M_Walk_Strafe_Right_002.glb',
                crouch: 'animation-library-master/masculine/glb/locomotion/M_Crouch_Walk_003.glb',
                falling: 'animation-library-master/masculine/glb/locomotion/M_Falling_Idle_002.glb'
            };
            
            // Resolve all paths
            animationLibrary = {};
            for (const [key, relativePath] of Object.entries(animations)) {
                animationLibrary[key] = await getAnimationPath(relativePath);
            }
            
            console.log('Animation library initialized with paths:', animationLibrary);
            return animationLibrary;
        }
        
        // Blinking system
        let blinkInterval = null;
        
        function startBlinking() {
            if (blinkInterval) return; // Already blinking
            
            function randomBlink() {
                if (!morphTargetMeshes.length) return;
                
                // Random blink every 2-5 seconds
                const nextBlinkTime = 2000 + Math.random() * 3000;
                
                blinkInterval = setTimeout(() => {
                    // Blink animation (fast close, slower open)
                    morphTargetMeshes.forEach(mesh => {
                        const dict = mesh.morphTargetDictionary;
                        const influences = mesh.morphTargetInfluences;
                        
                        if (dict['eyeBlinkLeft'] !== undefined && dict['eyeBlinkRight'] !== undefined) {
                            const leftIdx = dict['eyeBlinkLeft'];
                            const rightIdx = dict['eyeBlinkRight'];
                            
                            // Close eyes
                            influences[leftIdx] = 1.0;
                            influences[rightIdx] = 1.0;
                            
                            // Open after 100ms
                            setTimeout(() => {
                                influences[leftIdx] = 0;
                                influences[rightIdx] = 0;
                            }, 100);
                        }
                    });
                    
                    randomBlink(); // Schedule next blink
                }, nextBlinkTime);
            }
            
            randomBlink();
        }
        
        function stopBlinking() {
            if (blinkInterval) {
                clearTimeout(blinkInterval);
                blinkInterval = null;
            }
        }

        async function loadAvatarModel(url) {
            if (!avatarRenderer) {
                initAvatarScene();
            }

            // Clear previous avatar
            if (avatarModel) {
                avatarScene.remove(avatarModel);
                avatarModel = null;
            }
            morphTargetMeshes = [];
            
            // Resolve local file paths using the same method as animations
            let resolvedUrl = url;
            if (url.startsWith('src/')) {
                resolvedUrl = await getAnimationPath(url);
            }

            console.log('[AVATAR] Loading model from:', resolvedUrl);
            console.log('[AVATAR] Three.js version:', THREE.REVISION);

            const loader = new THREE.GLTFLoader();
            
            // Set timeout for loading
            const loadTimeout = setTimeout(() => {
                console.error('[AVATAR] Load timeout after 10 seconds');
            }, 10000);
            
            loader.load(resolvedUrl, (gltf) => {
                clearTimeout(loadTimeout);
                
                // Validate GLTF structure
                if (!gltf || !gltf.scene) {
                    console.error('[AVATAR] Invalid GLTF: missing scene');
                    return;
                }
                
                // Check for common corruption issues
                let hasValidGeometry = false;
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        if (!child.geometry) {
                            console.warn('[AVATAR] Mesh has null geometry:', child.name || 'unnamed');
                        } else {
                            hasValidGeometry = true;
                        }
                    }
                });
                
                if (!hasValidGeometry) {
                    console.error('[AVATAR] Model has no valid geometry - corrupted file');
                    return;
                }
                
                // Setup model
                try {
                    avatarModel = gltf.scene;
                    avatarModel.position.set(0, 0, 0);
                    avatarModel.scale.set(1, 1, 1);
                    avatarScene.add(avatarModel);
                    console.log('[AVATAR] ‚úì Model added to scene');

                    // AnimationMixer - wrap in try-catch as it can fail
                    try {
                        avatarMixer = new THREE.AnimationMixer(avatarModel);
                        console.log('[AVATAR] ‚úì AnimationMixer created');
                    } catch (mixerErr) {
                        console.error('[AVATAR] AnimationMixer failed:', mixerErr.message);
                        console.log('[AVATAR] Model will display without animations');
                        avatarMixer = null;
                    }
                } catch (err) {
                    console.error('[AVATAR] Error setting up model:', err.message);
                    console.error('[AVATAR] Stack:', err.stack);
                    return;
                }

                // Find morph targets for lip-sync
                avatarModel.traverse((child) => {
                    // Comprehensive null checks to prevent errors
                    if (!child) {
                        console.warn('[AVATAR] Skipping null child in traverse');
                        return;
                    }
                    
                    if (child.isMesh && child.morphTargetDictionary && child.morphTargetInfluences) {
                        try {
                            // Safe property access
                            const dict = child.morphTargetDictionary;
                            const influences = child.morphTargetInfluences;
                            
                            if (!dict || !influences) {
                                console.warn('[AVATAR] Mesh has null morph target data');
                                return;
                            }
                            
                            const targets = Object.keys(dict);
                            if (targets.length > 0) {
                                morphTargetMeshes.push(child);
                                // Safe name access with fallback
                                const meshName = (child && child.name) ? child.name : 'unnamed';
                                console.log('[AVATAR] Found morph targets in mesh "' + meshName + '":', targets.slice(0, 5).join(',') + '...');
                            }
                        } catch (err) {
                            console.warn('[AVATAR] Error processing morph targets for mesh:', err.message);
                            console.warn('[AVATAR] Error stack:', err.stack);
                        }
                    }
                });

                console.log('[AVATAR] Model loaded successfully (' + morphTargetMeshes.length + ' meshes with morph targets)');

                // Load idle animation from animation library
                loadAnimation('idle');
            }, undefined, (error) => {
                console.error('[AVATAR] Failed to load model:', error);
                console.error('[AVATAR] Error type:', error.constructor.name);
                console.error('[AVATAR] Error message:', error.message || 'No message');
                console.error('[AVATAR] Error stack:', error.stack || 'No stack');
                console.error('[AVATAR] URL attempted:', resolvedUrl);
                
                // Try to diagnose the issue
                if (error.message && error.message.includes('null')) {
                    console.error('[AVATAR] This model may have missing/corrupted bones, materials, or mesh data');
                    console.error('[AVATAR] Try a different avatar or check if the GLB file is valid');
                }
            });
        }

        function loadAnimation(animType, forceInterrupt = false) {
            if (!avatarMixer || !animationLibrary[animType]) {
                console.log('[AVATAR] Cannot load animation:', animType);
                return;
            }
            
            // If force interrupt, immediately stop any current animation
            if (forceInterrupt) {
                console.log('[AVATAR] ‚ö†Ô∏è Force interrupting current animation for:', animType);
                if (currentAnimation) {
                    currentAnimation.stop();
                }
                // Temporarily disable lip-sync to prevent mouth movements during celebration
                const wasSpeaking = isSpeaking;
                if (wasSpeaking) {
                    console.log('[AVATAR] Pausing lip-sync for celebration');
                    // Will resume after celebration finishes
                }
            }
            
            const animPath = animationLibrary[animType];
            console.log('[AVATAR] Loading animation:', animType, 'from', animPath);

            const loader = new THREE.GLTFLoader();
            loader.load(animPath, (gltf) => {
                if (gltf.animations && gltf.animations.length > 0) {
                    console.log('[AVATAR] Loaded ' + gltf.animations.length + ' animations from ' + animType);
                    
                    // Stop current animation
                    if (currentAnimation) {
                        currentAnimation.fadeOut(0.5);
                    }
                    
                    // Play new animation
                    const clip = gltf.animations[0];
                    if (!clip || !clip.tracks || clip.tracks.length === 0) {
                        console.error('[AVATAR] Invalid animation clip:', clip);
                        return;
                    }
                    
                    try {
                        currentAnimation = avatarMixer.clipAction(clip);
                        currentAnimation.reset();
                        currentAnimation.fadeIn(0.5);
                        currentAnimation.play();
                    } catch (err) {
                        console.error('[AVATAR] Failed to play animation:', err.message);
                        return;
                    }
                    
                    // If not idle, return to idle after animation finishes
                    if (animType !== 'idle') {
                        currentAnimation.setLoop(THREE.LoopOnce);
                        currentAnimation.clampWhenFinished = true;
                        setTimeout(() => {
                            loadAnimation('idle');
                        }, clip.duration * 1000);
                    }
                    
                    console.log('[AVATAR] ‚úì Playing ' + animType + ' animation');
                } else {
                    console.log('[AVATAR] No animations found in ' + animType);
                }
            }, undefined, async (error) => {
                console.error('[AVATAR] Failed to load ' + animType + ' animation:', error);
                console.log('[AVATAR] Trying fallback path...');
                // Fallback to resolved path via getAnimationPath
                const fallbackRelative = 'animation-library-master/masculine/glb/' + animType.replace('idle', 'idle/M_Standing_Idle_001') + '.glb';
                try {
                    const fallbackURL = await getAnimationPath(fallbackRelative);
                    console.log('[AVATAR] Fallback resolved to:', fallbackURL);
                    loader.load(fallbackURL, (gltf) => {
                        console.log('[AVATAR] Loaded fallback animation for ' + animType);
                        if (gltf.animations && gltf.animations.length > 0) {
                            if (currentAnimation) currentAnimation.fadeOut(0.5);
                            const clip = gltf.animations[0];
                            if (!clip || !clip.tracks || clip.tracks.length === 0) {
                                console.error('[AVATAR] Invalid animation clip (fallback):', clip);
                                return;
                            }
                            try {
                                currentAnimation = avatarMixer.clipAction(clip);
                                currentAnimation.reset();
                                currentAnimation.fadeIn(0.5);
                                currentAnimation.play();
                            } catch (err) {
                                console.error('[AVATAR] Failed to play fallback animation:', err.message);
                                return;
                            }
                            if (animType !== 'idle') {
                                currentAnimation.setLoop(THREE.LoopOnce);
                                currentAnimation.clampWhenFinished = true;
                                setTimeout(() => loadAnimation('idle'), clip.duration * 1000);
                            }
                            console.log('[AVATAR] ‚úì Playing (fallback) ' + animType + ' animation');
                        } else {
                            console.log('[AVATAR] No animations found in fallback for ' + animType);
                        }
                    }, undefined, (err2) => {
                        console.error('[AVATAR] Failed to load fallback animation for ' + animType + ':', err2);
                    });
                } catch (e) {
                    console.error('[AVATAR] Error resolving fallback path for ' + animType + ':', e);
                }
            });
        }
        
        // Trigger animations based on game events
        function triggerAnimationForEvent(eventType, interruptCurrent = false) {
            if (!avatarModel) return;
            
            console.log('[AVATAR] Event triggered:', eventType, interruptCurrent ? '(INTERRUPT)' : '');
            
            switch(eventType) {
                case 'goal_scored':
                    // Randomize celebration
                    const celebrations = ['celebrate', 'victory', 'dance', 'cheer'];
                    const celebration = celebrations[Math.floor(Math.random() * celebrations.length)];
                    loadAnimation(celebration, interruptCurrent);
                    break;
                case 'assist':
                    loadAnimation('cheer');
                    break;
                case 'save':
                case 'epic_save':
                    loadAnimation('excited');
                    break;
                case 'demo':
                case 'demolition':
                    loadAnimation('dance');
                    break;
                case 'shot':
                    loadAnimation('point');
                    break;
                case 'miss':
                    loadAnimation('frustrated');
                    break;
                default:
                    console.log('[AVATAR] Unknown event:', eventType);
            }
        }
        
        // Animation cooldown system - prevent jerky repeated triggering
        let lastAnimationTrigger = 0;
        let lastTriggeredAnimation = '';
        const ANIMATION_COOLDOWN = 3000; // 3 seconds cooldown
        
        // Track last known goal count to detect new goals
        let lastGoalCount = 0;
        
        // Animation cycling for varied talking animations
        let talkingAnimationIndex = 0;
        let idleAnimationIndex = 0;
        const talkingAnimations = ['talking', 'talking2', 'talking3'];
        const idleVariations = ['idle', 'idle_casual', 'idle_var1', 'idle_var2', 'idle_var3'];
        
        function getNextTalkingAnimation() {
            const anim = talkingAnimations[talkingAnimationIndex];
            talkingAnimationIndex = (talkingAnimationIndex + 1) % talkingAnimations.length;
            return anim;
        }
        
        function getNextIdleAnimation() {
            const anim = idleVariations[idleAnimationIndex];
            idleAnimationIndex = (idleAnimationIndex + 1) % idleVariations.length;
            return anim;
        }
        
        // Detect expressions and actions from speech content
        function detectSpeechExpressions(text) {
            if (!avatarModel || !text) return;
            
            const lowerText = text.toLowerCase();
            
            // Emotional expressions
            if (lowerText.match(/\b(ha+h+a+|heh+|lol|lmao|hilarious|funny|comedy)\b/)) {
                console.log('[AVATAR] üòÇ Laugh detected in speech');
                setTimeout(() => loadAnimation('laugh'), 200);
            }
            else if (lowerText.match(/\b(excited|amazing|incredible|awesome|wow+|whoa+|holy)\b/)) {
                console.log('[AVATAR] ü§© Excitement detected in speech');
                setTimeout(() => loadAnimation('excited'), 200);
            }
            else if (lowerText.match(/\b(happy|great|excellent|fantastic|wonderful)\b/)) {
                console.log('[AVATAR] üòä Happiness detected in speech');
                setTimeout(() => loadAnimation('happy'), 200);
            }
            else if (lowerText.match(/\b(surprised|shocking|unexpected|can't believe|no way)\b/)) {
                console.log('[AVATAR] üò≤ Surprise detected in speech');
                setTimeout(() => loadAnimation('surprised'), 200);
            }
            else if (lowerText.match(/\b(thinking|hmm+|uh+|let me think|wondering|maybe|perhaps)\b/)) {
                console.log('[AVATAR] ü§î Thinking detected in speech');
                setTimeout(() => loadAnimation('thinking'), 200);
            }
            else if (lowerText.match(/\b(frustrated|damn|darn|annoying|ugh|argh)\b/)) {
                console.log('[AVATAR] üò§ Frustration detected in speech');
                setTimeout(() => loadAnimation('frustrated'), 200);
            }
            else if (lowerText.match(/\b(don't know|not sure|shrug|whatever|dunno)\b/)) {
                console.log('[AVATAR] ü§∑ Shrug detected in speech');
                setTimeout(() => loadAnimation('shrug'), 200);
            }
            else if (lowerText.match(/\b(yes|yeah|yep|correct|right|exactly|absolutely|agree)\b/)) {
                console.log('[AVATAR] üëç Agreement detected in speech');
                setTimeout(() => loadAnimation('nod'), 200);
            }
            
            // Action expressions
            else if (lowerText.match(/\b(look at|check out|see that|over there|pointing)\b/)) {
                console.log('[AVATAR] üëâ Pointing detected in speech');
                setTimeout(() => loadAnimation('point'), 200);
            }
            
            // Movement keywords
            else if (lowerText.match(/\b(walking|moving|going|heading|approaching)\b/)) {
                console.log('[AVATAR] üö∂ Walking mentioned in speech');
                setTimeout(() => loadAnimation('walk'), 300);
            }
            else if (lowerText.match(/\b(running|sprint|rush|hurry|fast)\b/)) {
                console.log('[AVATAR] üèÉ Running mentioned in speech');
                setTimeout(() => loadAnimation('run'), 300);
            }
            else if (lowerText.match(/\b(jumping|leap|hop|airborne|aerial)\b/)) {
                console.log('[AVATAR] ü¶ò Jumping mentioned in speech');
                setTimeout(() => loadAnimation('jump'), 300);
            }
            else if (lowerText.match(/\b(falling|dropped|descending|down)\b/)) {
                console.log('[AVATAR] ü™Ç Falling mentioned in speech');
                setTimeout(() => loadAnimation('falling'), 300);
            }
            
            // If no specific expression matched, cycle through talking animations every few seconds
            else if (Math.random() < 0.3) { // 30% chance to vary animation
                const nextAnim = getNextTalkingAnimation();
                console.log('[AVATAR] üîÑ Cycling to:', nextAnim);
                setTimeout(() => loadAnimation(nextAnim), 500);
            }
        }
        
        function checkForGoalEvent(gameState) {
            if (!gameState || gameState.goals === undefined) return;
            
            const currentGoals = gameState.goals;
            
            // Detect goal increase
            if (currentGoals > lastGoalCount && lastGoalCount > 0) {
                console.log('[AVATAR] üö® GOAL DETECTED from tracking data! Goals: ' + lastGoalCount + ' -> ' + currentGoals);
                // Immediately trigger celebration (interrupt any current animation)
                triggerAnimationForEvent('goal_scored', true);
            }
            
            lastGoalCount = currentGoals;
        }
        
        // Voice command detection - trigger animations based on user commands
        function detectVoiceCommand(text) {
            if (!avatarModel) return;
            
            const lowerText = text.toLowerCase();
            const now = Date.now();
            
            // Determine which animation to trigger
            let targetAnimation = null;
            
            // Movement commands
            if (lowerText.includes('walk') || lowerText.includes('move forward')) {
                targetAnimation = 'walk';
            } else if (lowerText.includes('run')) {
                targetAnimation = 'run';
            } else if (lowerText.includes('jump')) {
                targetAnimation = 'jump';
            } else if (lowerText.includes('dance')) {
                const dances = ['dance', 'dance2', 'dance3'];
                targetAnimation = dances[Math.floor(Math.random() * dances.length)];
            } else if (lowerText.includes('wave') || lowerText.includes('hello') || lowerText.includes('hi')) {
                targetAnimation = 'wave';
            } else if (lowerText.includes('celebrate') || lowerText.includes('cheer')) {
                targetAnimation = 'celebrate';
            } else if (lowerText.includes('think') || lowerText.includes('hmm')) {
                targetAnimation = 'thinking';
            } else if (lowerText.includes('shrug')) {
                targetAnimation = 'shrug';
            } else if (lowerText.includes('laugh') || lowerText.includes('funny')) {
                targetAnimation = 'laugh';
            } else if (lowerText.includes('nod') || lowerText.includes('yes')) {
                targetAnimation = 'nod';
            } else if (lowerText.includes('crouch') || lowerText.includes('duck')) {
                targetAnimation = 'crouch';
            } else if (lowerText.includes('strafe left') || lowerText.includes('left')) {
                targetAnimation = 'strafe_left';
            } else if (lowerText.includes('strafe right') || lowerText.includes('right')) {
                targetAnimation = 'strafe_right';
            }
            
            // Apply cooldown - don't trigger same animation too quickly
            if (targetAnimation) {
                const timeSinceLastTrigger = now - lastAnimationTrigger;
                
                if (targetAnimation === lastTriggeredAnimation && timeSinceLastTrigger < ANIMATION_COOLDOWN) {
                    console.log('[AVATAR] Animation cooldown active - ignoring repeated trigger (' + timeSinceLastTrigger + 'ms ago)');
                    return;
                }
                
                // Trigger animation
                console.log('[AVATAR] Voice command detected: "' + text + '" -> ' + targetAnimation);
                loadAnimation(targetAnimation);
                lastAnimationTrigger = now;
                lastTriggeredAnimation = targetAnimation;
            }
        }

        function loadSelectedAvatar() {
            const selector = document.getElementById('avatarSelector');
            const value = selector.value;
            const statusDiv = document.getElementById('avatarStatus');

            if (value === '') {
                // No avatar selected
                currentAvatarPath = null;
                statusDiv.textContent = 'No avatar loaded';
                statusDiv.style.color = '#aaa';
                document.getElementById('avatarContainer').style.display = 'none';
                return;
            }

            if (value === 'url') {
                // Create input dialog (prompt() not supported in Electron)
                const url = window.prompt ? window.prompt('Enter avatar GLB URL:', 'https://models.readyplayer.me/YOUR_AVATAR_ID.glb?morphTargets=OculusVisemes,ARKit') : null;
                if (!url) {
                    // Fallback: use simple text input
                    const urlInput = document.createElement('input');
                    urlInput.type = 'text';
                    urlInput.placeholder = 'https://models.readyplayer.me/YOUR_ID.glb?morphTargets=ARKit';
                    urlInput.style.cssText = 'width: 100%; padding: 8px; margin: 5px 0; border: 2px solid #8B00FF; background: #222; color: white; border-radius: 6px;';
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 2px solid #8B00FF; padding: 20px; border-radius: 12px; z-index: 10000; min-width: 400px;';
                    dialog.innerHTML = '<h3 style="color: #8B00FF; margin: 0 0 10px 0;">üåê Load Avatar from URL</h3>';
                    dialog.appendChild(urlInput);
                    
                    const btnContainer = document.createElement('div');
                    btnContainer.style.cssText = 'display: flex; gap: 10px; margin-top: 15px;';
                    
                    const loadBtn = document.createElement('button');
                    loadBtn.textContent = 'Load';
                    loadBtn.style.cssText = 'flex: 1; padding: 10px; background: #00AA00; border: none; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;';
                    loadBtn.onclick = () => {
                        const enteredURL = urlInput.value.trim();
                        if (enteredURL) {
                            currentAvatarPath = enteredURL;
                            statusDiv.textContent = '‚úì Loaded: Custom URL';
                            statusDiv.style.color = '#00ff00';
                            console.log('[AVATAR] URL loaded:', currentAvatarPath);
                            showAndLoadAvatar(currentAvatarPath);
                        }
                        document.body.removeChild(dialog);
                    };
                    
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.style.cssText = 'flex: 1; padding: 10px; background: #666; border: none; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;';
                    cancelBtn.onclick = () => {
                        selector.value = '';
                        document.body.removeChild(dialog);
                    };
                    
                    btnContainer.appendChild(loadBtn);
                    btnContainer.appendChild(cancelBtn);
                    dialog.appendChild(btnContainer);
                    document.body.appendChild(dialog);
                    urlInput.focus();
                    
                    // Enter key to submit
                    urlInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') loadBtn.click();
                    });
                } else if (url.trim()) {
                    currentAvatarPath = url.trim();
                    statusDiv.textContent = '‚úì Loaded: Custom URL';
                    statusDiv.style.color = '#00ff00';
                    console.log('[AVATAR] URL loaded:', currentAvatarPath);
                    showAndLoadAvatar(currentAvatarPath);
                } else {
                    selector.value = '';
                }
                return;
            }

            if (value === 'custom') {
                // Trigger file picker
                document.getElementById('avatarFilePicker').click();
                // Reset selector to previous value
                selector.value = currentAvatarPath ? 'custom' : '';
                return;
            }

            // Load default avatar
            currentAvatarPath = avatarURLs[value];
            statusDiv.textContent = '‚úì Loaded: ' + value;
            statusDiv.style.color = '#00ff00';
            console.log('[AVATAR] Selected:', value, 'Path:', currentAvatarPath);

            showAndLoadAvatar(currentAvatarPath);
        }

        function showAndLoadAvatar(path) {
            // Show avatar container and load model
            const container = document.getElementById('avatarContainer');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                setTimeout(() => {
                    loadAvatarModel(path);
                    // Update button text
                    document.getElementById('avatarWindowBtn').textContent = '‚ùå Hide Avatar';
                    document.getElementById('avatarWindowBtn').style.background = '#ff0000';
                }, 100);
            } else {
                loadAvatarModel(path);
            }
        }

        function loadCustomAvatar() {
            const filePicker = document.getElementById('avatarFilePicker');
            const file = filePicker.files[0];
            const statusDiv = document.getElementById('avatarStatus');

            if (!file) {
                console.log('[AVATAR] No file selected');
                return;
            }

            // Create a local URL for the file
            const fileURL = URL.createObjectURL(file);
            currentAvatarPath = fileURL;

            statusDiv.textContent = '‚úì Loaded: ' + file.name;
            statusDiv.style.color = '#00ff00';
            console.log('[AVATAR] Custom file selected:', file.name);

            // Update selector to show custom
            document.getElementById('avatarSelector').value = 'custom';

            showAndLoadAvatar(currentAvatarPath);
        }

        // Load avatar from URL input
        function loadAvatarFromUrl() {
            const input = document.getElementById('avatarUrlInput');
            const url = input.value.trim();
            
            if (!url) {
                console.log('[AVATAR] No URL provided');
                return;
            }
            
            // Validate URL format
            if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('blob:')) {
                console.error('[AVATAR] Invalid URL format - must start with http:// or https://');
                alert('Invalid URL format. Please use a full URL starting with https://');
                return;
            }
            
            console.log('[AVATAR] Loading from custom URL:', url);
            currentAvatarPath = url;
            loadAvatarModel(url);
            
            // Clear input
            input.value = '';
        }
        
        // Track ball position for avatar rotation
        let lastBallX = 0.5; // Normalized 0-1 (center)
        let continuousTrackingEnabled = true;
        
        function updateAvatarRotation(ballX, force = false) {
            if (!avatarModel) return;
            
            // Don't auto-rotate if user is manually controlling (unless forced)
            if (!force && window.isManualControl && window.isManualControl()) {
                return;
            }
            
            // Normalize ball position to -1 to 1 range
            const normalizedX = (ballX - 0.5) * 2;
            
            // Rotate avatar to look at ball (subtle movement)
            const targetRotation = normalizedX * 0.3; // Max 0.3 radians (~17 degrees)
            
            // Smooth interpolation
            const currentRotation = avatarModel.rotation.y;
            avatarModel.rotation.y += (targetRotation - currentRotation) * 0.05;
            
            lastBallX = ballX;
        }
        
        function toggleAvatarWindow() {
            const container = document.getElementById('avatarContainer');
            const btn = document.getElementById('avatarWindowBtn');

            if (container.style.display === 'none') {
                container.style.display = 'block';
                btn.textContent = '‚ùå Hide Avatar';
                btn.style.background = '#ff0000';

                // Load avatar if one is selected
                if (currentAvatarPath) {
                    setTimeout(() => loadAvatarModel(currentAvatarPath), 100);
                }
            } else {
                container.style.display = 'none';
                btn.textContent = 'üì∫ Show Avatar';
                btn.style.background = '#444';
            }
        }

        // Minimal test caption helper (fix for missing testCaption reference)
        function testCaption(text) {
            console.log('[TEST] testCaption:', text);

            try {
                // Support both new ID-based caption elements and legacy class-based ones
                const card = document.querySelector('.caption-card') || document.getElementById('captionCard');
                const captionEl = document.querySelector('.caption-text') || document.getElementById('captionText');

                if (!card || !captionEl) {
                    console.warn('[TEST] Caption elements not found');
                    return;
                }

                // Use textContent to avoid HTML injection
                captionEl.textContent = text;

                // Show the caption (support both patterns)
                if (card.id === 'captionCard') {
                    card.style.display = 'block';
                } else {
                    card.classList.add('active');
                }

                // Determine duration from UI (eg "10s") or default to 10s
                let duration = 10;
                const durEl = document.getElementById('captionDurationValue');
                if (durEl) {
                    const m = durEl.textContent && durEl.textContent.match(/(\d+)/);
                    if (m) duration = parseInt(m[1], 10) || duration;
                }

                // Try speaking via Web Speech API first (works in Electron renderer)
                try {
                    if (window.speechSynthesis) {
                        const utt = new SpeechSynthesisUtterance(text);
                        window.speechSynthesis.cancel(); // Cancel any current speech
                        window.speechSynthesis.speak(utt);
                    } else {
                        // Fallback: attempt to call local API if available (non-blocking)
                        fetch('/api/speak', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text })
                        }).catch(() => {});
                    }
                } catch (e) {
                    console.warn('[TEST] TTS failed:', e);
                }

                // Auto-hide after duration seconds
                setTimeout(() => {
                    if (card.id === 'captionCard') {
                        card.style.display = 'none';
                    } else {
                        card.classList.remove('active');
                    }
                }, duration * 1000);
            } catch (ex) {
                console.error('[TEST] testCaption error:', ex);
            }
        }

        // Lip-sync system - maps phonemes to ARKit visemes
        const phonemeToViseme = {
            'AA': 'jawOpen',
            'AE': 'jawOpen',
            'AH': 'jawOpen',
            'AO': 'mouthFunnel',
            'AW': 'mouthFunnel',
            'AY': 'jawOpen',
            'B': 'mouthClose',
            'CH': 'mouthPucker',
            'D': 'mouthClose',
            'DH': 'mouthClose',
            'EH': 'mouthSmileLeft',
            'ER': 'mouthFunnel',
            'EY': 'mouthSmileLeft',
            'F': 'mouthLowerDownLeft',
            'G': 'jawOpen',
            'HH': 'jawOpen',
            'IH': 'mouthSmileLeft',
            'IY': 'mouthSmileLeft',
            'JH': 'mouthPucker',
            'K': 'jawOpen',
            'L': 'mouthClose',
            'M': 'mouthClose',
            'N': 'mouthClose',
            'NG': 'mouthClose',
            'OW': 'mouthFunnel',
            'OY': 'mouthFunnel',
            'P': 'mouthClose',
            'R': 'mouthFunnel',
            'S': 'mouthSmileLeft',
            'SH': 'mouthPucker',
            'T': 'mouthClose',
            'TH': 'mouthClose',
            'UH': 'mouthFunnel',
            'UW': 'mouthFunnel',
            'V': 'mouthLowerDownLeft',
            'W': 'mouthFunnel',
            'Y': 'mouthSmileLeft',
            'Z': 'mouthSmileLeft',
            'ZH': 'mouthPucker',
            'sil': null
        };
        
        let currentVisemeTargets = {}; // Stores target values for smooth interpolation
        let lerpSpeed = 0.25; // How fast to transition (0.1 = slow, 0.5 = fast) - slower default
        let isSpeaking = false; // Track if currently speaking
        let speechDuration = 0; // Total duration of speech
        
        function startLipSync(phonemes) {
            if (!avatarModel || morphTargetMeshes.length === 0) {
                console.log('[LIP-SYNC] No avatar or morph targets available');
                return;
            }
            
            phonemeQueue = phonemes.slice();
            
            // CRITICAL: Recalculate duration from RECEIVED phonemes (already scaled by backend)
            // Backend scales phonemes to match audio, so last phoneme's end = actual audio end
            if (phonemeQueue.length > 0) {
                const lastPhoneme = phonemeQueue[phonemeQueue.length - 1];
                speechDuration = lastPhoneme.start + (lastPhoneme.duration || 0.05);
                
                // Verify phoneme timing makes sense
                const firstPhoneme = phonemeQueue[0];
                console.log('[LIP-SYNC] üìä Phoneme timing: first=' + firstPhoneme.start.toFixed(2) + 's, last=' + lastPhoneme.start.toFixed(2) + 's, duration=' + speechDuration.toFixed(2) + 's');
            } else {
                speechDuration = 0;
            }
            
            console.log('[LIP-SYNC] ‚úì Starting lip-sync with', phonemeQueue.length, 'phonemes, duration:', speechDuration.toFixed(2) + 's');
            
            // Switch to talking animation
            loadAnimation('talking');
            
            // Start blinking if not already
            startBlinking();
            
            // Slow down lerp for more natural speech
            isSpeaking = true;
            lerpSpeed = 0.08; // Much slower during speech for natural movement
            
            if (lipSyncInterval) clearInterval(lipSyncInterval);
            
            let startTime = Date.now();
            let phonemeIndex = 0;
            let intervalCount = 0;
            currentVisemeTargets = {}; // Reset targets
            
            lipSyncInterval = setInterval(() => {
                intervalCount++;
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Check for pauses between words (gaps > 0.2s = word boundary)
                let inPause = false;
                if (phonemeIndex < phonemeQueue.length) {
                    const currentPhoneme = phonemeQueue[phonemeIndex];
                    const gap = currentPhoneme.start - currentTime;
                    
                    // If we're waiting for next phoneme and gap is significant, we're in a pause
                    if (gap > 0.2 && gap < 2.0) {
                        inPause = true;
                        // During pauses, rapidly close mouth to neutral
                        Object.keys(currentVisemeTargets).forEach(key => {
                            currentVisemeTargets[key] *= 0.5; // Decay targets quickly
                        });
                        lerpSpeed = 0.5; // Faster closure during pause
                    } else if (!inPause) {
                        lerpSpeed = 0.08; // Normal speech speed (very slow)
                    }
                }
                
                // Process new phonemes (only log occasionally to reduce spam)
                while (phonemeIndex < phonemeQueue.length && phonemeQueue[phonemeIndex].start <= currentTime) {
                    const phoneme = phonemeQueue[phonemeIndex];
                    if (intervalCount % 30 === 0) { // Log every 0.5 seconds instead of every phoneme
                        console.log('[LIP-SYNC]', phonemeIndex + '/' + phonemeQueue.length, 'at', currentTime.toFixed(1) + 's');
                    }
                    setPhonemeTarget(phoneme.phoneme);
                    phonemeIndex++;
                }
                
                // Smoothly interpolate towards target values
                updateMorphTargetsSmooth();
                
                // Stop when audio duration is reached (not just when phonemes processed)
                if (currentTime >= speechDuration && speechDuration > 0) {
                    clearInterval(lipSyncInterval);
                    lipSyncInterval = null;
                    console.log('[LIP-SYNC] ‚úì Finished - duration:', currentTime.toFixed(1) + 's');
                    
                    // Reset mouth immediately
                    currentVisemeTargets = {};
                    resetMouth();
                    
                    // Reset lerp speed and speaking flag
                    isSpeaking = false;
                    lerpSpeed = 0.25; // Reset to slower default
                    speechDuration = 0;
                    
                    // Return to varied idle animation
                    setTimeout(() => {
                        const idleAnim = getNextIdleAnimation();
                        console.log('[AVATAR] Speech ended - returning to:', idleAnim);
                        loadAnimation(idleAnim);
                    }, 300);
                }
            }, 16); // 60fps
        }
        
        function setPhonemeTarget(phoneme) {
            const viseme = phonemeToViseme[phoneme];
            
            if (!viseme) {
                // Silence - reset targets to 0
                currentVisemeTargets = {};
                return;
            }
            
            // Set target values for smooth interpolation
            currentVisemeTargets = {};
            currentVisemeTargets[viseme] = 0.7; // Main viseme
            
            // Add jaw opening for vowels
            if (['AA', 'AE', 'AH', 'AO', 'AW', 'AY', 'EH', 'EY', 'IH', 'IY', 'UH', 'UW'].includes(phoneme)) {
                currentVisemeTargets['jawOpen'] = 0.4;
            }
        }
        
        function updateMorphTargetsSmooth() {
            morphTargetMeshes.forEach(mesh => {
                const dict = mesh.morphTargetDictionary;
                const influences = mesh.morphTargetInfluences;
                
                // Smoothly transition all mouth morphs
                Object.keys(dict).forEach(key => {
                    if (key.startsWith('mouth') || key === 'jawOpen') {
                        const targetValue = currentVisemeTargets[key] || 0;
                        const currentValue = influences[dict[key]];
                        // Lerp: newValue = current + (target - current) * speed
                        influences[dict[key]] = currentValue + (targetValue - currentValue) * lerpSpeed;
                    }
                });
            });
        }
        
        function resetMouth() {
            morphTargetMeshes.forEach(mesh => {
                const dict = mesh.morphTargetDictionary;
                const influences = mesh.morphTargetInfluences;
                
                // Smoothly reset all mouth morphs
                Object.keys(dict).forEach(key => {
                    if (key.startsWith('mouth') || key === 'jawOpen') {
                        influences[dict[key]] = 0;
                    }
                });
            });
        }

        // Dragging functionality for avatar container (entire container is draggable)
        const avatarContainer = document.getElementById('avatarContainer');
        // avatarDragging and avatarDragOffset already declared at top of file

        avatarContainer.addEventListener('mousedown', (e) => {
            // Only drag if clicking on the container itself, not the canvas
            if (e.target === avatarContainer || e.target.id === 'avatarCanvas') {
                avatarDragging = true;
                const rect = avatarContainer.getBoundingClientRect();
                avatarDragOffset.x = e.clientX - rect.left;
                avatarDragOffset.y = e.clientY - rect.top;
                avatarContainer.style.cursor = 'grabbing';
                e.preventDefault(); // Prevent text selection
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (avatarDragging) {
                const newLeft = e.clientX - avatarDragOffset.x;
                const newTop = e.clientY - avatarDragOffset.y;
                avatarContainer.style.left = newLeft + 'px';
                avatarContainer.style.top = newTop + 'px';
                avatarContainer.style.bottom = 'auto'; // Remove bottom positioning
            }
        });

        document.addEventListener('mouseup', () => {
            if (avatarDragging) {
                avatarDragging = false;
                avatarContainer.style.cursor = 'move';
            }
        });

        // Cleanup
        window.addEventListener('unload', () => {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
        });
    </script>
</body>
</html>
